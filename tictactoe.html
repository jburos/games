<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Tic Tac Toe - Free Kids Game No Ads | Play Online</title>
<meta name="description" content="Play Tic Tac Toe for free! Kids game with no ads. Classic tic-tac-toe with customizable grid sizes, win conditions, and win probability visualization." />
<meta name="keywords" content="tic tac toe, free tic tac toe, kids games, games without ads, strategy games, noughts and crosses, no ads games, safe games for kids, educational games, logic games" />
<meta name="author" content="Games Collection" />
<meta name="robots" content="index, follow" />
<link rel="canonical" href="https://games.example.com/tictactoe.html" />

<!-- Open Graph / Facebook -->
<meta property="og:type" content="website" />
<meta property="og:url" content="https://games.example.com/tictactoe.html" />
<meta property="og:title" content="Tic Tac Toe - Free Kids Game No Ads" />
<meta property="og:description" content="Play Tic Tac Toe for free! Kids game with no ads. Classic tic-tac-toe with customizable grid sizes and win probability visualization." />
<meta property="og:site_name" content="Games Collection" />

<!-- Twitter -->
<meta property="twitter:card" content="summary" />
<meta property="twitter:url" content="https://games.example.com/tictactoe.html" />
<meta property="twitter:title" content="Tic Tac Toe - Free Kids Game No Ads" />
<meta property="twitter:description" content="Play Tic Tac Toe for free! Kids game with no ads. Classic tic-tac-toe with customizable grid sizes." />

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "VideoGame",
  "name": "Tic Tac Toe",
  "description": "A free online Tic Tac Toe game for kids with no ads. Classic tic-tac-toe with customizable grid sizes, win conditions, and win probability visualization.",
  "applicationCategory": "Game",
  "operatingSystem": "Web Browser",
  "gameGenre": "Strategy",
  "offers": {
    "@type": "Offer",
    "price": "0",
    "priceCurrency": "USD"
  },
  "audience": {
    "@type": "Audience",
    "audienceType": "Children"
  },
  "gameItem": {
    "@type": "Thing",
    "name": "Tic Tac Toe",
    "description": "Classic strategy game with customizable grid sizes"
  }
}
</script>
<style>
  body {
    font-family: Arial, sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    margin-top: 40px;
  }

  #board {
    display: grid;
    grid-gap: 5px;
  }

  .cell {
    display: flex;
    justify-content: center;
    align-items: center;
    background: #eee;
    cursor: pointer;
  }

  .cell.size-3 {
    width: 100px;
    height: 100px;
    font-size: 2.5rem;
  }

  .cell.size-4 {
    width: 80px;
    height: 80px;
    font-size: 2rem;
  }

  .cell.size-5 {
    width: 65px;
    height: 65px;
    font-size: 1.6rem;
  }

  .cell.size-6 {
    width: 55px;
    height: 55px;
    font-size: 1.3rem;
  }

  .cell.x {
    color: #2563eb;
    font-weight: bold;
  }

  .cell.o {
    color: #dc2626;
    font-weight: bold;
  }

  #status {
    margin-top: 20px;
    font-size: 1.4rem;
  }

  #status.player-x {
    color: #2563eb;
    font-weight: bold;
  }

  #status.player-o {
    color: #dc2626;
    font-weight: bold;
  }

  #controls {
    margin-bottom: 20px;
    display: flex;
    gap: 10px;
    align-items: center;
  }

  #gridSizeLabel {
    font-size: 1rem;
  }

  #gridSizeSelect,
  #winLengthSelect {
    padding: 6px 12px;
    font-size: 1rem;
    border: 1px solid #ccc;
    border-radius: 4px;
  }

  button {
    margin-top: 10px;
    padding: 8px 16px;
    font-size: 1rem;
  }

  #probabilityViz {
    margin-top: 20px;
    width: 100%;
    max-width: 400px;
    padding: 15px;
    background: #f9f9f9;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  }

  #probabilityViz h3 {
    margin: 0 0 15px 0;
    font-size: 1.1rem;
    text-align: center;
    color: #333;
  }

  .prob-bar-container {
    margin-bottom: 12px;
  }

  .prob-label {
    display: flex;
    justify-content: space-between;
    margin-bottom: 5px;
    font-size: 0.9rem;
  }

  .prob-label-name {
    font-weight: bold;
  }

  .prob-bar {
    height: 25px;
    border-radius: 4px;
    transition: width 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-weight: bold;
    font-size: 0.85rem;
  }

  .prob-bar-x {
    background: #2563eb;
  }

  .prob-bar-o {
    background: #dc2626;
  }

  .prob-bar-tie {
    background: #6b7280;
  }

  .cell-probability {
    position: absolute;
    bottom: 2px;
    right: 2px;
    font-size: 0.6rem;
    color: #666;
    font-weight: normal;
    background: rgba(255, 255, 255, 0.8);
    padding: 2px 4px;
    border-radius: 3px;
  }

  .cell {
    position: relative;
  }
</style>
</head>
<body>

<div style="position: absolute; top: 20px; left: 20px; z-index: 10;">
  <a href="index.html" style="display: inline-block; padding: 8px 16px; background: #2563eb; color: white; text-decoration: none; border-radius: 4px; font-size: 0.95rem; font-weight: bold; transition: background 0.2s, transform 0.2s;" onmouseover="this.style.background='#1d4ed8'; this.style.transform='translateY(-2px)'" onmouseout="this.style.background='#2563eb'; this.style.transform=''">‚Üê Back to Home</a>
</div>

<h1>Tic Tac Toe</h1>
<div id="controls">
  <label id="gridSizeLabel" for="gridSizeSelect">Grid Size:</label>
  <select id="gridSizeSelect">
    <option value="3">3x3</option>
    <option value="4">4x4</option>
    <option value="5">5x5</option>
    <option value="6">6x6</option>
  </select>
  <label id="winLengthLabel" for="winLengthSelect">Win Length:</label>
  <select id="winLengthSelect">
    <option value="3">3 in a row</option>
  </select>
</div>
<div id="board"></div>
<div id="status"></div>
<div id="probabilityViz">
  <h3>Win Probability</h3>
  <div class="prob-bar-container">
    <div class="prob-label">
      <span class="prob-label-name">Player X</span>
      <span id="probX">0%</span>
    </div>
    <div class="prob-bar prob-bar-x" id="barX" style="width: 0%">0%</div>
  </div>
  <div class="prob-bar-container">
    <div class="prob-label">
      <span class="prob-label-name">Player O</span>
      <span id="probO">0%</span>
    </div>
    <div class="prob-bar prob-bar-o" id="barO" style="width: 0%">0%</div>
  </div>
  <div class="prob-bar-container">
    <div class="prob-label">
      <span class="prob-label-name">Tie</span>
      <span id="probTie">0%</span>
    </div>
    <div class="prob-bar prob-bar-tie" id="barTie" style="width: 0%">0%</div>
  </div>
</div>
<button id="resetBtn">Reset</button>

<script>
  const board = document.getElementById("board");
  const statusText = document.getElementById("status");
  const resetBtn = document.getElementById("resetBtn");
  const gridSizeSelect = document.getElementById("gridSizeSelect");
  const winLengthSelect = document.getElementById("winLengthSelect");

  let currentPlayer = "X";
  let gameActive = true;
  let gridSize = 3;
  let winLength = 3;
  let state = [];
  let winningCombos = [];
  let showProbabilities = false;
  let spacebarPressed = false;

  function generateWinningCombos(size, length) {
    const combos = [];
    
    // Generate all horizontal sequences (rows)
    for (let row = 0; row < size; row++) {
      for (let startCol = 0; startCol <= size - length; startCol++) {
        const combo = [];
        for (let i = 0; i < length; i++) {
          combo.push(row * size + startCol + i);
        }
        combos.push(combo);
      }
    }
    
    // Generate all vertical sequences (columns)
    for (let col = 0; col < size; col++) {
      for (let startRow = 0; startRow <= size - length; startRow++) {
        const combo = [];
        for (let i = 0; i < length; i++) {
          combo.push((startRow + i) * size + col);
        }
        combos.push(combo);
      }
    }
    
    // Generate all diagonal sequences (top-left to bottom-right)
    for (let startRow = 0; startRow <= size - length; startRow++) {
      for (let startCol = 0; startCol <= size - length; startCol++) {
        const combo = [];
        for (let i = 0; i < length; i++) {
          combo.push((startRow + i) * size + (startCol + i));
        }
        combos.push(combo);
      }
    }
    
    // Generate all anti-diagonal sequences (top-right to bottom-left)
    for (let startRow = 0; startRow <= size - length; startRow++) {
      for (let startCol = length - 1; startCol < size; startCol++) {
        const combo = [];
        for (let i = 0; i < length; i++) {
          combo.push((startRow + i) * size + (startCol - i));
        }
        combos.push(combo);
      }
    }
    
    return combos;
  }

  function checkWinner(boardState) {
    const stateToCheck = boardState || state;
    for (const combo of winningCombos) {
      const first = stateToCheck[combo[0]];
      if (first && combo.every(index => stateToCheck[index] === first)) {
        return first;
      }
    }
    return stateToCheck.every(v => v) ? "tie" : null;
  }

  function calculateWinProbabilities() {
    if (!gameActive) {
      // Game is over, show final result
      const winner = checkWinner();
      if (winner === "X") {
        updateProbabilityViz(100, 0, 0);
      } else if (winner === "O") {
        updateProbabilityViz(0, 100, 0);
      } else if (winner === "tie") {
        updateProbabilityViz(0, 0, 100);
      }
      return;
    }

    // Adjust simulation count based on grid size and remaining moves
    const emptyCells = state.filter(cell => cell === "").length;
    let simulations = 500;
    if (gridSize >= 5) {
      simulations = 300; // Fewer simulations for larger grids
    } else if (gridSize === 4) {
      simulations = 400;
    }
    // Reduce simulations if there are many empty cells (early game)
    if (emptyCells > gridSize * gridSize * 0.7) {
      simulations = Math.floor(simulations * 0.7);
    }

    let xWins = 0;
    let oWins = 0;
    let ties = 0;

    for (let i = 0; i < simulations; i++) {
      const result = simulateRandomGame();
      if (result === "X") xWins++;
      else if (result === "O") oWins++;
      else ties++;
    }

    const probX = (xWins / simulations) * 100;
    const probO = (oWins / simulations) * 100;
    const probTie = (ties / simulations) * 100;

    updateProbabilityViz(probX, probO, probTie);
  }

  function calculateCellProbability(cellIndex) {
    if (state[cellIndex] !== "" || !gameActive) {
      return null;
    }

    // Create a temporary state with the current player's move
    const tempState = [...state];
    tempState[cellIndex] = currentPlayer;

    // Check if this move wins immediately
    const immediateWinner = checkWinner(tempState);
    if (immediateWinner === currentPlayer) {
      return 100; // Guaranteed win
    }
    if (immediateWinner === "tie") {
      return 0; // Guaranteed tie
    }

    // Simulate random games from this position
    const emptyCells = tempState.filter(cell => cell === "").length;
    let simulations = 200; // Fewer simulations per cell for performance
    if (gridSize >= 5) {
      simulations = 100;
    } else if (gridSize === 4) {
      simulations = 150;
    }
    if (emptyCells > gridSize * gridSize * 0.7) {
      simulations = Math.floor(simulations * 0.7);
    }

    let wins = 0;
    const nextPlayer = currentPlayer === "X" ? "O" : "X";

    for (let i = 0; i < simulations; i++) {
      const result = simulateRandomGameFromState(tempState, nextPlayer);
      if (result === currentPlayer) {
        wins++;
      }
    }

    return Math.round((wins / simulations) * 100);
  }

  function simulateRandomGameFromState(startState, startPlayer) {
    const simState = [...startState];
    const emptyIndices = [];
    for (let i = 0; i < simState.length; i++) {
      if (simState[i] === "") {
        emptyIndices.push(i);
      }
    }

    const shuffled = [...emptyIndices].sort(() => Math.random() - 0.5);
    let simPlayer = startPlayer;

    for (let i = 0; i < shuffled.length; i++) {
      const index = shuffled[i];
      simState[index] = simPlayer;
      
      const winner = checkWinner(simState);
      if (winner) {
        return winner;
      }
      
      simPlayer = simPlayer === "X" ? "O" : "X";
    }

    return "tie";
  }

  function updateCellProbabilities() {
    if (!showProbabilities || !gameActive) {
      // Remove all probability displays
      const cells = document.querySelectorAll('.cell');
      cells.forEach(cell => {
        const probElement = cell.querySelector('.cell-probability');
        if (probElement) {
          probElement.remove();
        }
      });
      return;
    }

    const cells = document.querySelectorAll('.cell');
    const emptyCells = [];
    
    // First pass: remove probabilities from filled cells and collect empty cells
    cells.forEach(cell => {
      const index = parseInt(cell.dataset.index);
      if (state[index] === "") {
        // Remove existing probability if any
        const existingProb = cell.querySelector('.cell-probability');
        if (existingProb) {
          existingProb.remove();
        }
        emptyCells.push({ cell, index });
      } else {
        // Remove probability from filled cells
        const probElement = cell.querySelector('.cell-probability');
        if (probElement) {
          probElement.remove();
        }
      }
    });

    // Calculate probabilities asynchronously to avoid blocking UI
    let cellIndex = 0;
    function calculateNextCell() {
      if (cellIndex >= emptyCells.length) {
        return;
      }

      const { cell, index } = emptyCells[cellIndex];
      const prob = calculateCellProbability(index);
      if (prob !== null) {
        const probElement = document.createElement('div');
        probElement.className = 'cell-probability';
        probElement.textContent = `${prob}%`;
        cell.appendChild(probElement);
      }

      cellIndex++;
      // Use setTimeout to allow UI to update between calculations
      setTimeout(calculateNextCell, 0);
    }

    // Start calculating probabilities
    if (emptyCells.length > 0) {
      calculateNextCell();
    }
  }

  function simulateRandomGame() {
    // Create a copy of the current state
    const simState = [...state];
    const emptyIndices = [];
    for (let i = 0; i < simState.length; i++) {
      if (simState[i] === "") {
        emptyIndices.push(i);
      }
    }

    // Shuffle empty indices for random play
    const shuffled = [...emptyIndices].sort(() => Math.random() - 0.5);
    let simPlayer = currentPlayer;

    // Play out the rest of the game randomly
    for (let i = 0; i < shuffled.length; i++) {
      const index = shuffled[i];
      simState[index] = simPlayer;
      
      const winner = checkWinner(simState);
      if (winner) {
        return winner;
      }
      
      simPlayer = simPlayer === "X" ? "O" : "X";
    }

    return "tie";
  }

  function updateProbabilityViz(probX, probO, probTie) {
    const barX = document.getElementById("barX");
    const barO = document.getElementById("barO");
    const barTie = document.getElementById("barTie");
    const textX = document.getElementById("probX");
    const textO = document.getElementById("probO");
    const textTie = document.getElementById("probTie");

    barX.style.width = `${probX}%`;
    barO.style.width = `${probO}%`;
    barTie.style.width = `${probTie}%`;

    textX.textContent = `${probX.toFixed(1)}%`;
    textO.textContent = `${probO.toFixed(1)}%`;
    textTie.textContent = `${probTie.toFixed(1)}%`;

    barX.textContent = probX > 5 ? `${probX.toFixed(1)}%` : "";
    barO.textContent = probO > 5 ? `${probO.toFixed(1)}%` : "";
    barTie.textContent = probTie > 5 ? `${probTie.toFixed(1)}%` : "";
  }

  function handleClick(e) {
    const cell = e.target;
    const index = parseInt(cell.dataset.index);

    if (state[index] !== "" || !gameActive) {
      return;
    }

    state[index] = currentPlayer;
    cell.textContent = currentPlayer;
    cell.classList.add(currentPlayer.toLowerCase());
    
    const winner = checkWinner();
    if (winner) {
      gameActive = false;
      statusText.className = "";
      if (winner === "tie") {
        statusText.textContent = "It's a tie!";
      } else {
        statusText.textContent = `Player ${winner} wins!`;
        statusText.classList.add(`player-${winner.toLowerCase()}`);
      }
    } else {
      currentPlayer = currentPlayer === "X" ? "O" : "X";
      statusText.textContent = `Player ${currentPlayer}'s turn`;
      statusText.className = `player-${currentPlayer.toLowerCase()}`;
    }
    
    // Update win probabilities after each move
    setTimeout(() => {
      calculateWinProbabilities();
      if (showProbabilities) {
        updateCellProbabilities();
      }
    }, 10);
  }

  function renderBoard() {
    board.innerHTML = "";
    board.style.gridTemplateColumns = `repeat(${gridSize}, auto)`;
    
    const totalCells = gridSize * gridSize;
    for (let i = 0; i < totalCells; i++) {
      const cell = document.createElement("div");
      cell.className = `cell size-${gridSize}`;
      cell.dataset.index = i;
      cell.textContent = state[i] || "";
      if (state[i]) {
        cell.classList.add(state[i].toLowerCase());
      }
      cell.addEventListener("click", handleClick);
      board.appendChild(cell);
    }
    
    // Update cell probabilities if feature is enabled
    if (showProbabilities) {
      setTimeout(() => updateCellProbabilities(), 10);
    }
  }

  function updateWinLengthOptions() {
    winLengthSelect.innerHTML = "";
    const maxLength = Math.min(winLength, gridSize); // Ensure winLength doesn't exceed gridSize
    for (let i = 3; i <= gridSize; i++) {
      const option = document.createElement("option");
      option.value = i;
      option.textContent = `${i} in a row`;
      option.selected = i === maxLength;
      winLengthSelect.appendChild(option);
    }
    winLength = maxLength;
  }

  function resetGame() {
    currentPlayer = "X";
    gameActive = true;
    state = Array(gridSize * gridSize).fill("");
    winningCombos = generateWinningCombos(gridSize, winLength);
    statusText.textContent = `Player ${currentPlayer}'s turn`;
    statusText.className = `player-${currentPlayer.toLowerCase()}`;
    renderBoard();
    // Calculate initial probabilities
    setTimeout(() => calculateWinProbabilities(), 10);
  }

  function changeGridSize() {
    gridSize = parseInt(gridSizeSelect.value);
    updateWinLengthOptions();
    resetGame();
  }

  function changeWinLength() {
    winLength = parseInt(winLengthSelect.value);
    resetGame();
  }

  resetBtn.addEventListener("click", resetGame);
  gridSizeSelect.addEventListener("change", changeGridSize);
  winLengthSelect.addEventListener("change", changeWinLength);
  
  // Spacebar to toggle probability display (only once per press, not while held)
  document.addEventListener("keydown", (e) => {
    if (e.code === "Space" && e.target.tagName !== "INPUT" && e.target.tagName !== "SELECT" && e.target.tagName !== "BUTTON") {
      e.preventDefault();
      if (!spacebarPressed) {
        spacebarPressed = true;
        showProbabilities = !showProbabilities;
        updateCellProbabilities();
      }
    }
  });

  document.addEventListener("keyup", (e) => {
    if (e.code === "Space") {
      spacebarPressed = false;
    }
  });
  
  // Initialize the game
  updateWinLengthOptions();
  resetGame();
</script>
</body>
</html>
