<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Timed Tiling Challenge</title>
<style>
  body {
    font-family: Arial, sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    margin-top: 20px;
    background: #f5f5f5;
  }

  h1 {
    margin-bottom: 20px;
    color: #333;
  }

  #gameSetup {
    background: white;
    border-radius: 10px;
    padding: 30px;
    margin-bottom: 20px;
    text-align: center;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  }

  #gameSetup h2 {
    margin-bottom: 20px;
    color: #333;
  }

  .time-selector {
    display: flex;
    gap: 15px;
    justify-content: center;
    margin: 20px 0;
    flex-wrap: wrap;
  }

  .time-option {
    padding: 15px 30px;
    font-size: 1.1rem;
    background: #e5e7eb;
    border: 2px solid transparent;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s;
  }

  .time-option:hover {
    background: #d1d5db;
  }

  .time-option.selected {
    background: #3b82f6;
    color: white;
    border-color: #2563eb;
  }

  #controls {
    margin-bottom: 20px;
    display: flex;
    gap: 15px;
    align-items: center;
    flex-wrap: wrap;
    justify-content: center;
  }

  #rotationControls {
    display: flex;
    gap: 10px;
  }

  #rotationControls button {
    padding: 6px 12px;
    font-size: 0.9rem;
    background: #6b7280;
  }

  #rotationControls button:hover {
    background: #4b5563;
  }

  label {
    font-size: 1rem;
  }

  select, button {
    padding: 8px 12px;
    font-size: 1rem;
    border: 1px solid #ccc;
    border-radius: 4px;
    background: white;
    cursor: pointer;
  }

  button {
    background: #2563eb;
    color: white;
    border: none;
    font-weight: bold;
  }

  button:hover {
    background: #1d4ed8;
  }

  button:disabled {
    background: #ccc;
    cursor: not-allowed;
  }

  .game-stats {
    background: white;
    border-radius: 10px;
    padding: 15px 25px;
    margin-bottom: 20px;
    display: flex;
    gap: 30px;
    align-items: center;
    justify-content: center;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  }

  .stat-item {
    text-align: center;
  }

  .stat-label {
    font-size: 0.9rem;
    color: #666;
    margin-bottom: 5px;
  }

  .stat-value {
    font-size: 1.8rem;
    font-weight: bold;
    color: #333;
  }

  .stat-value.timer {
    color: #ef4444;
  }

  .stat-value.score {
    color: #10b981;
  }

  #gameContainer {
    display: flex;
    gap: 30px;
    justify-content: center;
    align-items: flex-start;
    flex-wrap: wrap;
  }

  #shapePreview {
    padding: 20px;
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    min-width: 150px;
  }

  #shapePreview h3 {
    margin: 0 0 15px 0;
    font-size: 1.1rem;
    color: #333;
    text-align: center;
  }

  #shapePreviewGrid {
    display: grid;
    gap: 3px;
    padding: 15px;
    background: #e5e5e5;
    border-radius: 4px;
    justify-content: center;
  }

  .preview-shape-cell {
    width: 30px;
    height: 30px;
    background: #2563eb;
    border-radius: 2px;
  }

  .preview-shape-cell.empty {
    background: transparent;
  }

  #board {
    display: grid;
    gap: 0;
    background: #333;
    padding: 0;
    border-radius: 4px;
    border: 2px solid #333;
  }

  .board-cell {
    background: white;
    border-radius: 0;
    transition: background 0.2s;
    margin: 0;
    border: 1px solid #e5e7eb;
  }

  .board-cell:hover {
    background: #e0e7ff;
  }

  .board-cell.filled {
    background: #2563eb;
  }

  .board-cell.filled-1 { background: #2563eb !important; }
  .board-cell.filled-2 { background: #dc2626 !important; }
  .board-cell.filled-3 { background: #16a34a !important; }
  .board-cell.filled-4 { background: #ca8a04 !important; }
  .board-cell.filled-5 { background: #9333ea !important; }
  .board-cell.filled-6 { background: #ea580c !important; }
  .board-cell.filled-7 { background: #0891b2 !important; }
  .board-cell.filled-8 { background: #be123c !important; }

  .board-cell.filled-1:hover,
  .board-cell.filled-2:hover,
  .board-cell.filled-3:hover,
  .board-cell.filled-4:hover,
  .board-cell.filled-5:hover,
  .board-cell.filled-6:hover,
  .board-cell.filled-7:hover,
  .board-cell.filled-8:hover {
    opacity: 0.7;
    cursor: pointer;
  }

  .board-cell.inactive {
    background: #d1d5db !important;
    opacity: 0.5;
  }

  .board-cell.scored {
    background: #9ca3af !important;
    opacity: 0.7;
  }

  .board-cell.scored.filled-1,
  .board-cell.scored.filled-2,
  .board-cell.scored.filled-3,
  .board-cell.scored.filled-4,
  .board-cell.scored.filled-5,
  .board-cell.scored.filled-6,
  .board-cell.scored.filled-7,
  .board-cell.scored.filled-8 {
    background: #9ca3af !important;
    opacity: 0.7;
  }

  .board-cell.preview {
    background: #93c5fd;
    opacity: 0.6;
  }

  .board-cell.preview-invalid {
    background: #fca5a5;
    opacity: 0.6;
  }

  #status {
    margin-top: 20px;
    font-size: 1.2rem;
    font-weight: bold;
    color: #333;
  }

  #status.win {
    color: #16a34a;
    font-size: 1.5rem;
  }

  .cell-size-3 { width: 60px; height: 60px; }
  .cell-size-4 { width: 50px; height: 50px; }
  .cell-size-5 { width: 45px; height: 45px; }
  .cell-size-6 { width: 40px; height: 40px; }
  .cell-size-7 { width: 35px; height: 35px; }
  .cell-size-8 { width: 32px; height: 32px; }

  #gameOver {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: white;
    padding: 40px;
    border-radius: 15px;
    text-align: center;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
    display: none;
    z-index: 1000;
    max-width: 500px;
    width: 90%;
  }

  #gameOver.show {
    display: block;
  }

  #gameOver h2 {
    font-size: 2rem;
    margin-bottom: 20px;
    color: #333;
  }

  .final-stats {
    margin: 20px 0;
    font-size: 1.2rem;
  }

  .final-score {
    font-size: 2.5rem;
    font-weight: bold;
    color: #10b981;
    margin: 20px 0;
  }
</style>
</head>
<body>

<h1>⏱️ Timed Tiling Challenge</h1>

<div id="gameSetup">
  <h2>Select Game Duration</h2>
  <div class="time-selector">
    <div class="time-option" data-minutes="4">4 Minutes</div>
    <div class="time-option selected" data-minutes="6">6 Minutes</div>
    <div class="time-option" data-minutes="10">10 Minutes</div>
  </div>
  <button id="startBtn">Start Game</button>
</div>

<div id="gameArea" style="display: none;">
  <div class="game-stats">
    <div class="stat-item">
      <div class="stat-label">Time Remaining</div>
      <div class="stat-value timer" id="timer">6:00</div>
    </div>
    <div class="stat-item">
      <div class="stat-label">Score</div>
      <div class="stat-value score" id="score">0</div>
    </div>
    <div class="stat-item">
      <div class="stat-label">Rows Completed</div>
      <div class="stat-value" id="rows">0</div>
    </div>
    <button id="pauseBtn">Pause</button>
  </div>

  <div id="controls">
    <label for="gridSizeSelect">Grid Size:</label>
    <select id="gridSizeSelect">
      <option value="4">4x4</option>
      <option value="5">5x5</option>
      <option value="6">6x6</option>
      <option value="7">7x7</option>
      <option value="8">8x8</option>
    </select>
    <div id="rotationControls">
      <button id="rotateLeftBtn">↺ Rotate Left</button>
      <button id="rotateRightBtn">↻ Rotate Right</button>
      <button id="flipVerticalBtn">↕ Flip Vertical</button>
      <button id="flipHorizontalBtn">↔ Flip Horizontal</button>
    </div>
    <button id="resetBtn">Reset</button>
  </div>

  <div id="gameContainer">
    <div id="shapePreview">
      <h3>Current Shape</h3>
      <div id="shapePreviewGrid"></div>
    </div>
    <div id="board"></div>
  </div>

  <div id="status">Click a cell to place the L-shape (click filled cells to remove)</div>
</div>

<div id="gameOver">
  <h2>Time's Up!</h2>
  <div class="final-score" id="finalScore">0</div>
  <div class="final-stats">
    <div>Rows Completed: <span id="finalRows">0</span></div>
    <div>Score: <span id="finalScoreText">0</span> points</div>
  </div>
  <button id="playAgainBtn">Play Again</button>
</div>

<script>
  const board = document.getElementById("board");
  const statusText = document.getElementById("status");
  const resetBtn = document.getElementById("resetBtn");
  const gridSizeSelect = document.getElementById("gridSizeSelect");
  const rotateLeftBtn = document.getElementById("rotateLeftBtn");
  const rotateRightBtn = document.getElementById("rotateRightBtn");
  const flipVerticalBtn = document.getElementById("flipVerticalBtn");
  const flipHorizontalBtn = document.getElementById("flipHorizontalBtn");
  const shapePreviewGrid = document.getElementById("shapePreviewGrid");
  const gameSetup = document.getElementById("gameSetup");
  const gameArea = document.getElementById("gameArea");
  const startBtn = document.getElementById("startBtn");
  const pauseBtn = document.getElementById("pauseBtn");
  const timerDisplay = document.getElementById("timer");
  const scoreDisplay = document.getElementById("score");
  const rowsDisplay = document.getElementById("rows");
  const gameOverDiv = document.getElementById("gameOver");
  const finalScoreDisplay = document.getElementById("finalScore");
  const finalScoreText = document.getElementById("finalScoreText");
  const finalRowsDisplay = document.getElementById("finalRows");
  const playAgainBtn = document.getElementById("playAgainBtn");

  let gridSize = 4;
  let boardState = [];
  let scoredRows = new Set(); // Track which rows have been scored
  let currentRotation = 0;
  let currentFlipVertical = false;
  let currentFlipHorizontal = false;
  let shapeIdCounter = 1;
  let previewRow = null;
  let previewCol = null;
  let gameDuration = 6; // minutes
  let timeRemaining = 360; // seconds
  let gameRunning = false;
  let gamePaused = false;
  let timerInterval = null;
  let score = 0;
  let rowsCompleted = 0;

  // L-Shape definition
  const lShape = [[0,0], [1,0], [2,0], [2,1]];

  function normalizeShape(cells) {
    const minRow = Math.min(...cells.map(c => c[0]));
    const minCol = Math.min(...cells.map(c => c[1]));
    return cells.map(([r, c]) => [r - minRow, c - minCol]);
  }

  function rotateShape(cells, rotations) {
    let rotated = cells.map(([r, c]) => [r, c]);
    for (let i = 0; i < rotations; i++) {
      rotated = rotated.map(([r, c]) => [-c, r]);
    }
    return normalizeShape(rotated);
  }

  function flipShape(cells, horizontal) {
    let flipped = cells.map(([r, c]) => [r, c]);
    if (horizontal) {
      const maxCol = Math.max(...flipped.map(c => c[1]));
      flipped = flipped.map(([r, c]) => [r, maxCol - c]);
    } else {
      const maxRow = Math.max(...flipped.map(c => c[0]));
      flipped = flipped.map(([r, c]) => [maxRow - r, c]);
    }
    return normalizeShape(flipped);
  }

  function getCurrentShape() {
    let shape = normalizeShape(lShape);
    shape = rotateShape(shape, currentRotation);
    if (currentFlipVertical) {
      shape = flipShape(shape, false);
    }
    if (currentFlipHorizontal) {
      shape = flipShape(shape, true);
    }
    return shape;
  }

  function renderShapePreview() {
    const shape = getCurrentShape();
    const maxRow = Math.max(...shape.map(c => c[0]));
    const maxCol = Math.max(...shape.map(c => c[1]));
    
    shapePreviewGrid.innerHTML = "";
    shapePreviewGrid.style.gridTemplateColumns = `repeat(${maxCol + 1}, auto)`;
    shapePreviewGrid.style.gridTemplateRows = `repeat(${maxRow + 1}, auto)`;
    
    for (let r = 0; r <= maxRow; r++) {
      for (let c = 0; c <= maxCol; c++) {
        const cell = document.createElement("div");
        cell.className = "preview-shape-cell";
        if (!shape.some(([sr, sc]) => sr === r && sc === c)) {
          cell.classList.add("empty");
        }
        shapePreviewGrid.appendChild(cell);
      }
    }
  }

  function canPlaceShape(row, col, shape) {
    // Ensure boardState is the correct size before checking
    if (boardState.length !== gridSize * gridSize) {
      return false;
    }
    
    for (const [dr, dc] of shape) {
      const r = row + dr;
      const c = col + dc;
      if (r < 0 || r >= gridSize || c < 0 || c >= gridSize) {
        return false;
      }
      // Don't allow placing on scored rows
      if (scoredRows.has(r)) {
        return false;
      }
      const index = r * gridSize + c;
      if (index >= boardState.length || boardState[index] !== 0) {
        return false;
      }
    }
    return true;
  }

  function placeShape(row, col, shape, shapeId) {
    // Double-check that we can place the shape before actually placing it
    if (!canPlaceShape(row, col, shape)) {
      return false;
    }
    
    // Ensure boardState is the correct size
    if (boardState.length !== gridSize * gridSize) {
      boardState = Array(gridSize * gridSize).fill(0);
    }
    
    for (const [dr, dc] of shape) {
      const r = row + dr;
      const c = col + dc;
      const index = r * gridSize + c;
      if (index >= 0 && index < boardState.length) {
        boardState[index] = shapeId;
      }
    }
    checkRows();
    renderBoard();
    return true;
  }

  function checkRows() {
    // Ensure boardState is the correct size
    if (boardState.length !== gridSize * gridSize) {
      boardState = Array(gridSize * gridSize).fill(0);
      return;
    }
    
    let rowsCleared = 0;
    
    // Check each row to see if it's complete
    for (let r = 0; r < gridSize; r++) {
      // Skip rows that are already scored
      if (scoredRows.has(r)) {
        continue;
      }
      
      const rowStart = r * gridSize;
      const rowEnd = rowStart + gridSize;
      const row = boardState.slice(rowStart, rowEnd);
      
      // Check if row is complete (all cells filled)
      const isRowComplete = row.every(cell => cell !== 0);
      
      if (isRowComplete) {
        // Mark this row as scored instead of removing it
        scoredRows.add(r);
        rowsCleared++;
      }
    }
    
    if (rowsCleared > 0) {
      rowsCompleted += rowsCleared;
      score += rowsCleared * 10;
      scoreDisplay.textContent = score;
      rowsDisplay.textContent = rowsCompleted;
    }
  }

  function removeShape(shapeId) {
    for (let i = 0; i < boardState.length; i++) {
      if (boardState[i] === shapeId) {
        boardState[i] = 0;
      }
    }
    renderBoard();
    statusText.textContent = "Shape removed. Click a cell to place a new shape.";
  }

  function clearPreview() {
    if (previewRow !== null && previewCol !== null) {
      const shape = getCurrentShape();
      const cells = document.querySelectorAll(".board-cell");
      
      for (const [dr, dc] of shape) {
        const r = previewRow + dr;
        const c = previewCol + dc;
        if (r >= 0 && r < gridSize && c >= 0 && c < gridSize) {
          const index = r * gridSize + c;
          const cell = cells[index];
          cell.classList.remove("preview", "preview-invalid");
        }
      }
    }
    previewRow = null;
    previewCol = null;
  }

  function showPreview(row, col) {
    clearPreview();
    
    // Ensure boardState is valid
    if (boardState.length !== gridSize * gridSize) {
      return;
    }
    
    const index = row * gridSize + col;
    if (index < 0 || index >= boardState.length || boardState[index] !== 0) {
      return;
    }

    const shape = getCurrentShape();
    const cells = document.querySelectorAll(".board-cell");
    
    let bestAnchorRow = null;
    let bestAnchorCol = null;
    let canPlace = false;
    
    for (const [dr, dc] of shape) {
      const anchorRow = row - dr;
      const anchorCol = col - dc;
      
      let clickedCellInPlacement = false;
      let clickedCellEmpty = true;
      for (const [sr, sc] of shape) {
        if (anchorRow + sr === row && anchorCol + sc === col) {
          clickedCellInPlacement = true;
          const checkIndex = row * gridSize + col;
          if (checkIndex >= 0 && checkIndex < boardState.length && boardState[checkIndex] !== 0) {
            clickedCellEmpty = false;
          }
          break;
        }
      }
      
      if ((!clickedCellInPlacement || clickedCellEmpty) && canPlaceShape(anchorRow, anchorCol, shape)) {
        bestAnchorRow = anchorRow;
        bestAnchorCol = anchorCol;
        canPlace = true;
        break;
      }
    }
    
    if (bestAnchorRow !== null && bestAnchorCol !== null) {
      for (const [dr, dc] of shape) {
        const r = bestAnchorRow + dr;
        const c = bestAnchorCol + dc;
        if (r >= 0 && r < gridSize && c >= 0 && c < gridSize) {
          const cellIndex = r * gridSize + c;
          if (cellIndex >= 0 && cellIndex < boardState.length && cellIndex < cells.length) {
            const cell = cells[cellIndex];
            if (boardState[cellIndex] === 0) {
              cell.classList.add(canPlace ? "preview" : "preview-invalid");
            }
          }
        }
      }
      
      previewRow = bestAnchorRow;
      previewCol = bestAnchorCol;
    }
  }

  function handleCellClick(row, col) {
    if (!gameRunning || gamePaused) return;
    
    // Ensure boardState is valid before accessing
    if (boardState.length !== gridSize * gridSize) {
      boardState = Array(gridSize * gridSize).fill(0);
    }
    
    const index = row * gridSize + col;
    if (index < 0 || index >= boardState.length) return;
    
    const shapeId = boardState[index];
    if (shapeId !== 0) {
      removeShape(shapeId);
      return;
    }

    const shape = getCurrentShape();
    
    if (previewRow !== null && previewCol !== null) {
      const previewShape = getCurrentShape();
      for (const [dr, dc] of previewShape) {
        const r = previewRow + dr;
        const c = previewCol + dc;
        if (r === row && c === col) {
          if (canPlaceShape(previewRow, previewCol, shape)) {
            if (placeShape(previewRow, previewCol, shape, shapeIdCounter++)) {
              clearPreview();
              statusText.textContent = "L-shape placed! Select another cell to place the shape.";
              return;
            }
          }
        }
      }
    }
    
    for (const [dr, dc] of shape) {
      const anchorRow = row - dr;
      const anchorCol = col - dc;
      
      if (canPlaceShape(anchorRow, anchorCol, shape)) {
        if (placeShape(anchorRow, anchorCol, shape, shapeIdCounter++)) {
          clearPreview();
          statusText.textContent = "L-shape placed! Select another cell to place the shape.";
          return;
        }
      }
    }
    
    statusText.textContent = "Cannot place L-shape here. Try another position.";
    statusText.style.color = "#dc2626";
    setTimeout(() => {
      statusText.style.color = "#333";
    }, 2000);
  }

  function renderBoard() {
    // Ensure boardState is always the correct size
    if (boardState.length !== gridSize * gridSize) {
      // If size doesn't match, pad or trim, but preserve existing pieces
      const correctSize = gridSize * gridSize;
      if (boardState.length < correctSize) {
        // Pad with zeros
        boardState = [...boardState, ...Array(correctSize - boardState.length).fill(0)];
      } else if (boardState.length > correctSize) {
        // Trim to correct size
        boardState = boardState.slice(0, correctSize);
      }
    }
    
    previewRow = null;
    previewCol = null;
    
    board.innerHTML = "";
    board.style.gridTemplateColumns = `repeat(${gridSize}, auto)`;
    
    for (let r = 0; r < gridSize; r++) {
      for (let c = 0; c < gridSize; c++) {
        const cell = document.createElement("div");
        const index = r * gridSize + c;
        const filledId = boardState[index] !== undefined ? boardState[index] : 0;
        const isScored = scoredRows.has(r);
        
        cell.className = `board-cell cell-size-${gridSize}`;
        if (filledId !== 0) {
          cell.classList.add(`filled-${(filledId - 1) % 8 + 1}`);
        }
        if (isScored) {
          cell.classList.add("scored");
        }
        
        cell.addEventListener("click", () => handleCellClick(r, c));
        cell.addEventListener("mouseenter", () => showPreview(r, c));
        cell.addEventListener("mouseleave", () => clearPreview());
        board.appendChild(cell);
      }
    }
  }

  function updateTimer() {
    if (gamePaused) return;
    
    timeRemaining--;
    const minutes = Math.floor(timeRemaining / 60);
    const seconds = timeRemaining % 60;
    timerDisplay.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    
    if (timeRemaining <= 0) {
      endGame();
    }
  }

  function startGame() {
    gameDuration = parseInt(document.querySelector(".time-option.selected").dataset.minutes);
    timeRemaining = gameDuration * 60;
    gameRunning = true;
    gamePaused = false;
    score = 0;
    rowsCompleted = 0;
    
    gridSize = parseInt(gridSizeSelect.value);
    boardState = Array(gridSize * gridSize).fill(0);
    scoredRows = new Set(); // Reset scored rows
    currentRotation = 0;
    currentFlipVertical = false;
    currentFlipHorizontal = false;
    shapeIdCounter = 1;
    
    scoreDisplay.textContent = "0";
    rowsDisplay.textContent = "0";
    statusText.textContent = "Click a cell to place the L-shape (click filled cells to remove)";
    statusText.className = "";
    
    gameSetup.style.display = "none";
    gameArea.style.display = "block";
    gameOverDiv.classList.remove("show");
    
    renderBoard();
    renderShapePreview();
    
    timerInterval = setInterval(updateTimer, 1000);
    updateTimer();
  }

  function pauseGame() {
    if (!gameRunning) return;
    gamePaused = !gamePaused;
    pauseBtn.textContent = gamePaused ? "Resume" : "Pause";
  }

  function endGame() {
    gameRunning = false;
    gamePaused = false;
    clearInterval(timerInterval);
    
    finalScoreDisplay.textContent = score;
    finalScoreText.textContent = score;
    finalRowsDisplay.textContent = rowsCompleted;
    gameOverDiv.classList.add("show");
  }

  function resetGame() {
    if (!gameRunning) {
      gridSize = parseInt(gridSizeSelect.value);
      boardState = Array(gridSize * gridSize).fill(0);
      scoredRows = new Set(); // Reset scored rows
      currentRotation = 0;
      currentFlipVertical = false;
      currentFlipHorizontal = false;
      shapeIdCounter = 1;
      renderBoard();
      renderShapePreview();
    }
  }

  function rotateLeft() {
    currentRotation = (currentRotation + 3) % 4;
    renderShapePreview();
    if (previewRow !== null && previewCol !== null) {
      showPreview(previewRow, previewCol);
    }
  }

  function rotateRight() {
    currentRotation = (currentRotation + 1) % 4;
    renderShapePreview();
    if (previewRow !== null && previewCol !== null) {
      showPreview(previewRow, previewCol);
    }
  }

  function flipVertical() {
    currentFlipVertical = !currentFlipVertical;
    renderShapePreview();
    if (previewRow !== null && previewCol !== null) {
      showPreview(previewRow, previewCol);
    }
  }

  function flipHorizontal() {
    currentFlipHorizontal = !currentFlipHorizontal;
    renderShapePreview();
    if (previewRow !== null && previewCol !== null) {
      showPreview(previewRow, previewCol);
    }
  }

  // Event listeners
  document.querySelectorAll(".time-option").forEach(option => {
    option.addEventListener("click", () => {
      document.querySelectorAll(".time-option").forEach(opt => opt.classList.remove("selected"));
      option.classList.add("selected");
    });
  });

  startBtn.addEventListener("click", startGame);
  pauseBtn.addEventListener("click", pauseGame);
  resetBtn.addEventListener("click", resetGame);
  gridSizeSelect.addEventListener("change", resetGame);
  rotateLeftBtn.addEventListener("click", rotateLeft);
  rotateRightBtn.addEventListener("click", rotateRight);
  flipVerticalBtn.addEventListener("click", flipVertical);
  flipHorizontalBtn.addEventListener("click", flipHorizontal);

  // Keyboard controls
  document.addEventListener("keydown", (e) => {
    if (e.target.tagName === "INPUT" || e.target.tagName === "SELECT" || e.target.tagName === "TEXTAREA") {
      return;
    }

    switch(e.key) {
      case "ArrowLeft":
        e.preventDefault();
        rotateLeft();
        break;
      case "ArrowRight":
        e.preventDefault();
        rotateRight();
        break;
      case "ArrowUp":
        e.preventDefault();
        flipVertical();
        break;
      case "ArrowDown":
        e.preventDefault();
        flipVertical();
        break;
    }
  });

  // Initialize
  resetGame();
</script>
</body>
</html>

