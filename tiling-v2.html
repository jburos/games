<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Tiling Puzzle V2 - Advanced</title>
<style>
  body {
    font-family: Arial, sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    margin-top: 20px;
    background: #f5f5f5;
  }

  h1 {
    margin-bottom: 20px;
    color: #333;
  }

  #controls {
    margin-bottom: 20px;
    display: flex;
    gap: 15px;
    align-items: center;
    flex-wrap: wrap;
    justify-content: center;
  }

  #rotationControls {
    display: flex;
    gap: 10px;
  }

  #rotationControls button {
    padding: 6px 12px;
    font-size: 0.9rem;
    background: #6b7280;
  }

  #rotationControls button:hover {
    background: #4b5563;
  }

  label {
    font-size: 1rem;
  }

  select, button {
    padding: 8px 12px;
    font-size: 1rem;
    border: 1px solid #ccc;
    border-radius: 4px;
    background: white;
    cursor: pointer;
  }

  button {
    background: #2563eb;
    color: white;
    border: none;
    font-weight: bold;
  }

  button:hover {
    background: #1d4ed8;
  }

  button:disabled {
    background: #ccc;
    cursor: not-allowed;
  }

  #gameContainer {
    display: flex;
    gap: 30px;
    justify-content: center;
    align-items: flex-start;
    flex-wrap: wrap;
  }

  #shapePreview {
    padding: 20px;
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    min-width: 150px;
    cursor: grab;
    user-select: none;
  }

  #shapePreview:active {
    cursor: grabbing;
  }

  #shapePreview h3 {
    margin: 0 0 15px 0;
    font-size: 1.1rem;
    color: #333;
    text-align: center;
  }

  #shapePreview.dragging {
    opacity: 0.5;
  }

  .drag-ghost {
    position: fixed;
    pointer-events: none;
    z-index: 10000;
    opacity: 0.8;
    transform: translate(-50%, -50%);
  }

  #shapePreviewGrid {
    display: grid;
    gap: 3px;
    padding: 15px;
    background: #e5e5e5;
    border-radius: 4px;
    justify-content: center;
  }

  .preview-shape-cell {
    width: 30px;
    height: 30px;
    background: #2563eb;
    border-radius: 2px;
  }

  .preview-shape-cell.empty {
    background: transparent;
  }

  #board {
    display: grid;
    gap: 2px;
    background: #333;
    padding: 2px;
    border-radius: 4px;
  }

  .board-cell {
    background: white;
    border-radius: 2px;
    transition: background 0.2s;
  }

  .board-cell:hover {
    background: #e0e7ff;
  }

  .board-cell.filled {
    background: #2563eb;
  }

  .board-cell.filled-1 { background: #2563eb !important; }
  .board-cell.filled-2 { background: #dc2626 !important; }
  .board-cell.filled-3 { background: #16a34a !important; }
  .board-cell.filled-4 { background: #ca8a04 !important; }
  .board-cell.filled-5 { background: #9333ea !important; }
  .board-cell.filled-6 { background: #ea580c !important; }
  .board-cell.filled-7 { background: #0891b2 !important; }
  .board-cell.filled-8 { background: #be123c !important; }

  .board-cell.filled-1:hover,
  .board-cell.filled-2:hover,
  .board-cell.filled-3:hover,
  .board-cell.filled-4:hover,
  .board-cell.filled-5:hover,
  .board-cell.filled-6:hover,
  .board-cell.filled-7:hover,
  .board-cell.filled-8:hover {
    opacity: 0.7;
    cursor: pointer;
  }

  .board-cell.inactive {
    background: #d1d5db !important;
    opacity: 0.5;
  }

  .board-cell.preview {
    background: #93c5fd;
    opacity: 0.6;
  }

  .board-cell.preview-invalid {
    background: #fca5a5;
    opacity: 0.6;
  }

  #status {
    margin-top: 20px;
    font-size: 1.2rem;
    font-weight: bold;
    color: #333;
  }

  #status.win {
    color: #16a34a;
    font-size: 1.5rem;
    animation: celebrate 0.6s ease-in-out infinite alternate;
  }

  @keyframes celebrate {
    0% {
      transform: scale(1);
    }
    100% {
      transform: scale(1.1);
    }
  }

  .confetti {
    position: fixed;
    width: 10px;
    height: 10px;
    background: #ff6b6b;
    pointer-events: none;
    z-index: 1000;
    animation: confetti-fall linear forwards;
  }

  @keyframes confetti-fall {
    0% {
      transform: translateY(-100vh) rotate(0deg);
      opacity: 1;
    }
    100% {
      transform: translateY(100vh) rotate(720deg);
      opacity: 0;
    }
  }

  .cell-size-3 { width: 60px; height: 60px; }
  .cell-size-4 { width: 50px; height: 50px; }
  .cell-size-5 { width: 45px; height: 45px; }
  .cell-size-6 { width: 40px; height: 40px; }
  .cell-size-7 { width: 35px; height: 35px; }
  .cell-size-8 { width: 32px; height: 32px; }
</style>
</head>
<body>

<h1>Tiling Puzzle V2 - Advanced</h1>

<div id="controls">
  <label for="gridSizeSelect">Grid Size:</label>
  <select id="gridSizeSelect">
    <option value="4">4x4</option>
    <option value="5">5x5</option>
    <option value="6">6x6</option>
    <option value="7">7x7</option>
    <option value="8">8x8</option>
  </select>
  <div id="rotationControls">
    <button id="rotateLeftBtn">â†º Rotate Left</button>
    <button id="rotateRightBtn">â†» Rotate Right</button>
    <button id="flipVerticalBtn">â†• Flip Vertical</button>
    <button id="flipHorizontalBtn">â†” Flip Horizontal</button>
  </div>
  <button id="resetBtn">Reset</button>
</div>

<div id="gameContainer">
  <div id="shapePreview">
    <h3>Current Shape</h3>
    <div id="shapePreviewGrid"></div>
  </div>
  <div id="board"></div>
</div>

<div id="status">Click and drag the shape to place it, or click a cell to place the L-shape (click filled cells to remove)</div>

<script>
  const board = document.getElementById("board");
  const statusText = document.getElementById("status");
  const resetBtn = document.getElementById("resetBtn");
  const gridSizeSelect = document.getElementById("gridSizeSelect");
  const rotateLeftBtn = document.getElementById("rotateLeftBtn");
  const rotateRightBtn = document.getElementById("rotateRightBtn");
  const flipVerticalBtn = document.getElementById("flipVerticalBtn");
  const flipHorizontalBtn = document.getElementById("flipHorizontalBtn");
  const shapePreviewGrid = document.getElementById("shapePreviewGrid");

  let gridSize = 4;
  let boardState = [];
  let currentRotation = 0;
  let currentFlipVertical = false;
  let currentFlipHorizontal = false;
  let shapeIdCounter = 1;
  let previewRow = null;
  let previewCol = null;
  let hasWon = false;

  // L-Shape definition (default)
  const defaultLShape = [[0,0], [1,0], [2,0], [2,1]];
  let lShape = defaultLShape;
  let customShapes = [];
  let customGridState = null; // null = all cells active, array = custom grid
  let isCustomProblem = false;

  function normalizeShape(cells) {
    // Normalize shape to start at [0,0]
    const minRow = Math.min(...cells.map(c => c[0]));
    const minCol = Math.min(...cells.map(c => c[1]));
    return cells.map(([r, c]) => [r - minRow, c - minCol]);
  }

  function rotateShape(cells, rotations) {
    let rotated = cells.map(([r, c]) => [r, c]);
    for (let i = 0; i < rotations; i++) {
      rotated = rotated.map(([r, c]) => [-c, r]);
    }
    return normalizeShape(rotated);
  }

  function flipShape(cells, horizontal) {
    let flipped = cells.map(([r, c]) => [r, c]);
    if (horizontal) {
      const maxCol = Math.max(...flipped.map(c => c[1]));
      flipped = flipped.map(([r, c]) => [r, maxCol - c]);
    } else {
      const maxRow = Math.max(...flipped.map(c => c[0]));
      flipped = flipped.map(([r, c]) => [maxRow - r, c]);
    }
    return normalizeShape(flipped);
  }

  function getCurrentShape() {
    let shape = normalizeShape(lShape);
    shape = rotateShape(shape, currentRotation);
    if (currentFlipVertical) {
      shape = flipShape(shape, false);
    }
    if (currentFlipHorizontal) {
      shape = flipShape(shape, true);
    }
    return shape;
  }

  function renderShapePreview() {
    const shape = getCurrentShape();
    const maxRow = Math.max(...shape.map(c => c[0]));
    const maxCol = Math.max(...shape.map(c => c[1]));
    
    shapePreviewGrid.innerHTML = "";
    shapePreviewGrid.style.gridTemplateColumns = `repeat(${maxCol + 1}, auto)`;
    shapePreviewGrid.style.gridTemplateRows = `repeat(${maxRow + 1}, auto)`;
    
    for (let r = 0; r <= maxRow; r++) {
      for (let c = 0; c <= maxCol; c++) {
        const cell = document.createElement("div");
        cell.className = "preview-shape-cell";
        if (!shape.some(([sr, sc]) => sr === r && sc === c)) {
          cell.classList.add("empty");
        }
        shapePreviewGrid.appendChild(cell);
      }
    }
    
    // Make preview draggable
    setupDragAndDrop();
  }
  
  function createDragGhost(shape) {
    const ghost = document.createElement("div");
    ghost.className = "drag-ghost";
    const maxRow = Math.max(...shape.map(c => c[0]));
    const maxCol = Math.max(...shape.map(c => c[1]));
    
    ghost.style.display = "grid";
    ghost.style.gridTemplateColumns = `repeat(${maxCol + 1}, auto)`;
    ghost.style.gap = "3px";
    ghost.style.padding = "10px";
    ghost.style.background = "rgba(37, 99, 235, 0.9)";
    ghost.style.borderRadius = "8px";
    ghost.style.boxShadow = "0 4px 12px rgba(0,0,0,0.3)";
    
    for (let r = 0; r <= maxRow; r++) {
      for (let c = 0; c <= maxCol; c++) {
        const cell = document.createElement("div");
        cell.style.width = "30px";
        cell.style.height = "30px";
        if (shape.some(([sr, sc]) => sr === r && sc === c)) {
          cell.style.background = "#2563eb";
          cell.style.borderRadius = "2px";
        } else {
          cell.style.background = "transparent";
        }
        ghost.appendChild(cell);
      }
    }
    
    return ghost;
  }
  
  let dragGhost = null;
  let isDragging = false;
  let dragMouseMoveHandler = null;
  let dragMouseUpHandler = null;
  
  function setupDragAndDrop() {
    const shapePreview = document.getElementById("shapePreview");
    if (!shapePreview) return;
    
    // Remove existing listeners if any
    if (dragMouseMoveHandler) {
      document.removeEventListener("mousemove", dragMouseMoveHandler);
    }
    if (dragMouseUpHandler) {
      document.removeEventListener("mouseup", dragMouseUpHandler);
    }
    
    // Use event delegation to avoid re-adding listeners
    shapePreview.onmousedown = (e) => {
      // Don't start drag if clicking on buttons or controls
      if (e.target.tagName === 'BUTTON' || e.target.closest('#rotationControls')) {
        return;
      }
      
      e.preventDefault();
      isDragging = true;
      const shape = getCurrentShape();
      dragGhost = createDragGhost(shape);
      document.body.appendChild(dragGhost);
      shapePreview.classList.add("dragging");
      
      const updateGhost = (e) => {
        if (dragGhost) {
          dragGhost.style.left = e.clientX + "px";
          dragGhost.style.top = e.clientY + "px";
        }
      };
      
      dragMouseMoveHandler = (e) => {
        if (isDragging && dragGhost) {
          updateGhost(e);
          // Update preview on board
          const boardRect = board.getBoundingClientRect();
          const x = e.clientX - boardRect.left;
          const y = e.clientY - boardRect.top;
          
          if (x >= 0 && x < boardRect.width && y >= 0 && y < boardRect.height) {
            const cellSize = boardRect.width / gridSize;
            const col = Math.floor(x / cellSize);
            const row = Math.floor(y / cellSize);
            
            if (row >= 0 && row < gridSize && col >= 0 && col < gridSize) {
              showPreview(row, col);
            }
          } else {
            clearPreview();
          }
        }
      };
      
      dragMouseUpHandler = (e) => {
        if (isDragging) {
          isDragging = false;
          shapePreview.classList.remove("dragging");
          
          if (dragGhost) {
            dragGhost.remove();
            dragGhost = null;
          }
          
          // Check if dropped on board
          const boardRect = board.getBoundingClientRect();
          const x = e.clientX - boardRect.left;
          const y = e.clientY - boardRect.top;
          
          if (x >= 0 && x < boardRect.width && y >= 0 && y < boardRect.height) {
            const cellSize = boardRect.width / gridSize;
            const col = Math.floor(x / cellSize);
            const row = Math.floor(y / cellSize);
            
            if (row >= 0 && row < gridSize && col >= 0 && col < gridSize) {
              handleCellClick(row, col);
            }
          }
          
          clearPreview();
          document.removeEventListener("mousemove", dragMouseMoveHandler);
          document.removeEventListener("mouseup", dragMouseUpHandler);
          dragMouseMoveHandler = null;
          dragMouseUpHandler = null;
        }
      };
      
      updateGhost(e);
      document.addEventListener("mousemove", dragMouseMoveHandler);
      document.addEventListener("mouseup", dragMouseUpHandler);
    };
  }

  function canPlaceShape(row, col, shape) {
    for (const [dr, dc] of shape) {
      const r = row + dr;
      const c = col + dc;
      if (r < 0 || r >= gridSize || c < 0 || c >= gridSize) {
        return false;
      }
      const index = r * gridSize + c;
      // Check if cell is in active grid area (for custom problems)
      if (customGridState && customGridState[index] === 0) {
        return false;
      }
      if (boardState[index] !== 0) {
        return false;
      }
    }
    return true;
  }

  function placeShape(row, col, shape, shapeId) {
    for (const [dr, dc] of shape) {
      const r = row + dr;
      const c = col + dc;
      boardState[r * gridSize + c] = shapeId;
    }
    renderBoard();
    // checkWin() is called by the caller to handle status messages properly
  }

  function removeShape(shapeId) {
    for (let i = 0; i < boardState.length; i++) {
      if (boardState[i] === shapeId) {
        boardState[i] = 0;
      }
    }
    renderBoard();
    // Only set status if player didn't win (unlikely after removing, but check anyway)
    if (!checkWin()) {
      statusText.textContent = "Shape removed. Click a cell to place a new shape.";
    }
  }

  function clearPreview() {
    if (previewRow !== null && previewCol !== null) {
      const shape = getCurrentShape();
      const cells = document.querySelectorAll(".board-cell");
      
      for (const [dr, dc] of shape) {
        const r = previewRow + dr;
        const c = previewCol + dc;
        if (r >= 0 && r < gridSize && c >= 0 && c < gridSize) {
          const index = r * gridSize + c;
          const cell = cells[index];
          cell.classList.remove("preview", "preview-invalid");
        }
      }
    }
    previewRow = null;
    previewCol = null;
  }

  function showPreview(row, col) {
    clearPreview();
    
    const shape = getCurrentShape();
    const cells = document.querySelectorAll(".board-cell");
    
    // Try to find a valid anchor point where the shape can be placed with the clicked cell as part of it
    let bestAnchorRow = null;
    let bestAnchorCol = null;
    let canPlace = false;
    
    // Try placing with clicked cell at each position in the shape
    for (const [dr, dc] of shape) {
      const anchorRow = row - dr;
      const anchorCol = col - dc;
      
      // Check if clicked cell would be part of this placement and is empty
      let clickedCellInPlacement = false;
      let clickedCellEmpty = true;
      for (const [sr, sc] of shape) {
        if (anchorRow + sr === row && anchorCol + sc === col) {
          clickedCellInPlacement = true;
          if (boardState[row * gridSize + col] !== 0) {
            clickedCellEmpty = false;
          }
          break;
        }
      }
      
      // Only try this anchor if clicked cell is either not in the placement, or is empty
      if ((!clickedCellInPlacement || clickedCellEmpty) && canPlaceShape(anchorRow, anchorCol, shape)) {
        bestAnchorRow = anchorRow;
        bestAnchorCol = anchorCol;
        canPlace = true;
        break;
      }
    }
    
    if (bestAnchorRow !== null && bestAnchorCol !== null) {
      // Show preview at the best anchor point
      for (const [dr, dc] of shape) {
        const r = bestAnchorRow + dr;
        const c = bestAnchorCol + dc;
        if (r >= 0 && r < gridSize && c >= 0 && c < gridSize) {
          const index = r * gridSize + c;
          const cell = cells[index];
          if (boardState[index] === 0) {
            cell.classList.add(canPlace ? "preview" : "preview-invalid");
          }
        }
      }
      
      previewRow = bestAnchorRow;
      previewCol = bestAnchorCol;
    }
  }

  function handleCellClick(row, col) {
    // If cell is filled, remove the shape
    const shapeId = boardState[row * gridSize + col];
    if (shapeId !== 0) {
      removeShape(shapeId);
      return;
    }

    const shape = getCurrentShape();
    
    // If there's an active preview and the clicked cell is part of it, use the preview's anchor
    if (previewRow !== null && previewCol !== null) {
      const previewShape = getCurrentShape();
      // Check if clicked cell is part of the preview
      for (const [dr, dc] of previewShape) {
        const r = previewRow + dr;
        const c = previewCol + dc;
        if (r === row && c === col) {
          // Clicked cell is part of preview, use preview's anchor
          if (canPlaceShape(previewRow, previewCol, shape)) {
            placeShape(previewRow, previewCol, shape, shapeIdCounter++);
            clearPreview();
            // Only set status if player didn't win
            if (!checkWin()) {
              statusText.textContent = "L-shape placed! Select another cell to place the shape.";
            }
            return;
          }
        }
      }
    }
    
    // Try placing with clicked cell at each position in the shape
    for (const [dr, dc] of shape) {
      const anchorRow = row - dr;
      const anchorCol = col - dc;
      
      if (canPlaceShape(anchorRow, anchorCol, shape)) {
        placeShape(anchorRow, anchorCol, shape, shapeIdCounter++);
        clearPreview();
        // Only set status if player didn't win
        if (!checkWin()) {
          statusText.textContent = "L-shape placed! Select another cell to place the shape.";
        }
        return;
      }
    }
    
    // If we get here, couldn't place the shape
    statusText.textContent = "Cannot place L-shape here. Try another position.";
    statusText.style.color = "#dc2626";
    setTimeout(() => {
      statusText.style.color = "#333";
    }, 2000);
  }

  function renderBoard() {
    // Reset preview tracking
    previewRow = null;
    previewCol = null;
    
    board.innerHTML = "";
    board.style.gridTemplateColumns = `repeat(${gridSize}, auto)`;
    
    for (let r = 0; r < gridSize; r++) {
      for (let c = 0; c < gridSize; c++) {
        const cell = document.createElement("div");
        const index = r * gridSize + c;
        const filledId = boardState[index];
        const isActive = !customGridState || customGridState[index] === 1;
        
        cell.className = `board-cell cell-size-${gridSize}`;
        if (!isActive) {
          cell.classList.add("inactive");
          cell.style.cursor = "not-allowed";
        }
        if (filledId !== 0) {
          cell.classList.add(`filled-${(filledId - 1) % 8 + 1}`);
        }
        
        if (isActive) {
          cell.addEventListener("click", () => handleCellClick(r, c));
          cell.addEventListener("mouseenter", () => showPreview(r, c));
          cell.addEventListener("mouseleave", () => clearPreview());
        }
        board.appendChild(cell);
      }
    }
  }

  function createConfetti() {
    const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#f0932b', '#eb4d4b', '#6c5ce7', '#a29bfe', '#00b894', '#00cec9'];
    const confettiCount = 100;
    
    for (let i = 0; i < confettiCount; i++) {
      setTimeout(() => {
        const confetti = document.createElement('div');
        confetti.className = 'confetti';
        confetti.style.left = Math.random() * 100 + '%';
        confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
        confetti.style.animationDuration = (Math.random() * 3 + 2) + 's';
        confetti.style.animationDelay = Math.random() * 0.5 + 's';
        confetti.style.width = (Math.random() * 10 + 8) + 'px';
        confetti.style.height = (Math.random() * 10 + 8) + 'px';
        confetti.style.borderRadius = Math.random() > 0.5 ? '50%' : '0%';
        
        document.body.appendChild(confetti);
        
        // Remove confetti after animation
        setTimeout(() => {
          confetti.remove();
        }, 5000);
      }, i * 10);
    }
  }

  function getRandomWinMessage() {
    const messages = [
      "ðŸŽ‰ Poop on your butt! You won!",
      "ðŸŽ‰ Awesome sauce! You did it!",
      "ðŸŽ‰ Holy guacamole! You're a winner!",
      "ðŸŽ‰ That's bananas! You won!",
      "ðŸŽ‰ You're the bee's knees! You won!",
      "ðŸŽ‰ That's totally tubular! You won!",
      "ðŸŽ‰ You're a rock star! You won!",
      "ðŸŽ‰ Cowabunga! You won!",
      "ðŸŽ‰ You're the cat's pajamas! You won!",
      "ðŸŽ‰ That's the bomb dot com! You won!",
      "ðŸŽ‰ You're cooler than a penguin! You won!",
      "ðŸŽ‰ That's rad! You won!",
      "ðŸŽ‰ You're the GOAT! You won!",
      "ðŸŽ‰ That's sick! You won!",
      "ðŸŽ‰ You're a legend! You won!",
      "ðŸŽ‰ No way! You actually did it!",
      "ðŸŽ‰ Mind blown! You won!",
      "ðŸŽ‰ You're a puzzle master! You won!",
      "ðŸŽ‰ That's epic! You won!",
      "ðŸŽ‰ You're unstoppable! You won!"
    ];
    return messages[Math.floor(Math.random() * messages.length)];
  }

  function checkWin() {
    let emptyActiveCells = 0;
    for (let i = 0; i < boardState.length; i++) {
      const isActive = !customGridState || customGridState[i] === 1;
      if (isActive && boardState[i] === 0) {
        emptyActiveCells++;
      }
    }
    
    if (emptyActiveCells === 0) {
      if (!hasWon) {
        hasWon = true;
        statusText.textContent = getRandomWinMessage();
        statusText.className = "win";
        createConfetti();
        return true; // Return true if player won
      }
      return true;
    } else {
      hasWon = false;
      statusText.textContent = `${emptyActiveCells} cell(s) remaining. Keep going!`;
      statusText.className = "";
      return false; // Return false if not won
    }
  }

  function loadCustomProblem() {
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get("custom") === "true") {
      const problemData = localStorage.getItem("customTilingProblem");
      if (problemData) {
        try {
          const problem = JSON.parse(problemData);
          isCustomProblem = true;
          gridSize = problem.gridSize;
          customGridState = problem.gridState;
          customShapes = problem.shapes;
          
          if (customShapes.length > 0) {
            lShape = customShapes[0]; // Use first shape as default
          }
          
          gridSizeSelect.value = gridSize;
          localStorage.removeItem("customTilingProblem"); // Clear after loading
          return true;
        } catch (e) {
          console.error("Error loading custom problem:", e);
        }
      }
    }
    return false;
  }

  function resetGame() {
    if (!isCustomProblem) {
      gridSize = parseInt(gridSizeSelect.value);
    }
    boardState = Array(gridSize * gridSize).fill(0);
    currentRotation = 0;
    currentFlipVertical = false;
    currentFlipHorizontal = false;
    shapeIdCounter = 1;
    hasWon = false;
    statusText.textContent = "Click a cell to place the shape (click filled cells to remove)";
    statusText.className = "";
    renderBoard();
    renderShapePreview();
  }

  function rotateLeft() {
    currentRotation = (currentRotation + 3) % 4;
    renderShapePreview();
    if (previewRow !== null && previewCol !== null) {
      showPreview(previewRow, previewCol);
    }
  }

  function rotateRight() {
    currentRotation = (currentRotation + 1) % 4;
    renderShapePreview();
    if (previewRow !== null && previewCol !== null) {
      showPreview(previewRow, previewCol);
    }
  }

  function flipVertical() {
    currentFlipVertical = !currentFlipVertical;
    renderShapePreview();
    if (previewRow !== null && previewCol !== null) {
      showPreview(previewRow, previewCol);
    }
  }

  function flipHorizontal() {
    currentFlipHorizontal = !currentFlipHorizontal;
    renderShapePreview();
    if (previewRow !== null && previewCol !== null) {
      showPreview(previewRow, previewCol);
    }
  }

  resetBtn.addEventListener("click", resetGame);
  gridSizeSelect.addEventListener("change", resetGame);
  rotateLeftBtn.addEventListener("click", rotateLeft);
  rotateRightBtn.addEventListener("click", rotateRight);
  flipVerticalBtn.addEventListener("click", flipVertical);
  flipHorizontalBtn.addEventListener("click", flipHorizontal);

  // Keyboard controls
  document.addEventListener("keydown", (e) => {
    // Only handle if not typing in an input/select
    if (e.target.tagName === "INPUT" || e.target.tagName === "SELECT" || e.target.tagName === "TEXTAREA") {
      return;
    }

    switch(e.key) {
      case "ArrowLeft":
        e.preventDefault();
        rotateLeft();
        break;
      case "ArrowRight":
        e.preventDefault();
        rotateRight();
        break;
      case "ArrowUp":
        e.preventDefault();
        flipVertical();
        break;
      case "ArrowDown":
        e.preventDefault();
        flipVertical();
        break;
    }
  });

  // Initialize
  if (loadCustomProblem()) {
    gridSizeSelect.disabled = true;
    gridSizeSelect.style.opacity = "0.5";
    statusText.textContent = "Custom problem loaded! Click a cell to place shapes.";
  }
  resetGame();
</script>
</body>
</html>

