<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Pong Escape</title>
<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  body {
    font-family: Arial, sans-serif;
    background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 20px;
    color: white;
  }

  .container {
    background: #1e293b;
    border-radius: 20px;
    padding: 20px;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    max-width: 95vw;
    width: 100%;
    max-height: 95vh;
    display: flex;
    flex-direction: column;
  }

  h1 {
    text-align: center;
    margin-bottom: 15px;
    font-size: clamp(1.5rem, 4vw, 2.5rem);
    background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }

  .game-info {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
    padding: 10px 15px;
    background: #0f172a;
    border-radius: 10px;
    flex-wrap: wrap;
    gap: 10px;
  }

  .score-display {
    display: flex;
    gap: clamp(10px, 2vw, 20px);
    align-items: center;
    flex-wrap: wrap;
  }

  .score, .wins, .losses {
    font-size: clamp(0.9rem, 2vw, 1.2rem);
    font-weight: bold;
  }

  .wins {
    color: #10b981;
  }

  .losses {
    color: #ef4444;
  }

  .status {
    font-size: clamp(0.9rem, 2vw, 1.1rem);
    padding: 8px 16px;
    border-radius: 8px;
    background: #334155;
  }

  .status.won {
    background: #10b981;
    color: white;
  }

  .status.lost {
    background: #ef4444;
    color: white;
  }

  #gameCanvas {
    display: block;
    margin: 0 auto;
    border: 3px solid #334155;
    border-radius: 10px;
    background: #0f172a;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    max-width: 100%;
    height: auto;
    width: 100%;
  }

  .canvas-wrapper {
    width: 100%;
    display: flex;
    justify-content: center;
    margin-bottom: 15px;
  }

  .controls {
    margin-top: 20px;
    text-align: center;
    padding: 15px;
    background: #0f172a;
    border-radius: 10px;
  }

  .controls p {
    margin-bottom: 10px;
    color: #cbd5e1;
  }

  .controls kbd {
    background: #334155;
    padding: 4px 8px;
    border-radius: 4px;
    font-family: monospace;
    font-size: 0.9rem;
    margin: 0 2px;
  }

  button {
    margin-top: 0;
    padding: clamp(8px, 1.5vw, 10px) clamp(16px, 3vw, 20px);
    font-size: clamp(0.85rem, 2vw, 0.95rem);
    background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-weight: bold;
    transition: transform 0.2s, box-shadow 0.2s;
  }

  button:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(59, 130, 246, 0.4);
  }

  button:active {
    transform: translateY(0);
  }

  .instructions {
    margin-top: 15px;
    padding: 15px;
    background: #0f172a;
    border-radius: 10px;
    border-left: 4px solid #3b82f6;
  }

  .instructions h3 {
    margin-bottom: 10px;
    color: #3b82f6;
    font-size: clamp(1rem, 2.5vw, 1.2rem);
  }

  .instructions ul {
    list-style-position: inside;
    color: #cbd5e1;
    line-height: 1.8;
    font-size: clamp(0.85rem, 2vw, 1rem);
  }

  .instructions li {
    margin-bottom: 5px;
  }

  @media (max-width: 768px) {
    .container {
      padding: 15px;
      max-width: 100vw;
    }

    .game-info {
      flex-direction: column;
      align-items: stretch;
    }

    .score-display {
      justify-content: space-around;
    }
  }

  @media (max-height: 700px) {
    .instructions {
      display: none;
    }
  }
</style>
</head>
<body>
  <div class="container">
    <h1>üèì Pong Escape</h1>
    
    <div class="game-info">
      <div class="score-display">
        <div class="score">Score: <span id="score">0</span></div>
        <div class="wins">Wins: <span id="wins">0</span></div>
        <div class="losses">Losses: <span id="losses">0</span></div>
      </div>
      <div class="status" id="status">Use arrow keys to move paddle</div>
      <button id="restartBtn">Restart Game</button>
    </div>

    <div class="canvas-wrapper">
      <canvas id="gameCanvas"></canvas>
    </div>

    <div class="controls">
      <p>Use <kbd>‚Üê</kbd> <kbd>‚Üí</kbd> arrow keys to move the paddle</p>
    </div>

    <div class="instructions">
      <h3>How to Play</h3>
      <ul>
        <li><strong>Score:</strong> Guide the ball into the goal at the top to score</li>
        <li><strong>Defend:</strong> Use the paddle to prevent the ball from falling into the pit</li>
        <li><strong>Angle:</strong> Hit the ball at different angles to direct it toward the goal</li>
        <li><strong>Win:</strong> Ball enters the goal - you scored!</li>
        <li><strong>Lose:</strong> Ball falls into the pit</li>
      </ul>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreElement = document.getElementById('score');
    const winsElement = document.getElementById('wins');
    const lossesElement = document.getElementById('losses');
    const statusElement = document.getElementById('status');
    const restartBtn = document.getElementById('restartBtn');

    // Game state
    let score = 0;
    let wins = 0;
    let losses = 0;
    let gameState = 'playing'; // 'playing', 'won', 'lost'
    let keys = {};

    // Base game dimensions (aspect ratio 4:3)
    const BASE_WIDTH = 800;
    const BASE_HEIGHT = 600;
    let canvasWidth = BASE_WIDTH;
    let canvasHeight = BASE_HEIGHT;
    let scale = 1;

    // Game dimensions (will be calculated based on canvas size)
    let PIT_WIDTH, PIT_X, PIT_Y, EXIT_WIDTH, EXIT_X, EXIT_Y, PADDLE_WIDTH, PADDLE_HEIGHT, BALL_RADIUS;

    // Ball
    let ball = {
      x: 0,
      y: 0,
      vx: 0,
      vy: 0,
      radius: 0
    };

    // Paddle
    let paddle = {
      x: 0,
      y: 0,
      width: 0,
      height: 0,
      speed: 0
    };

    // Walls (boundaries) - will be recalculated on resize
    let walls = [];

    // Function to resize canvas and recalculate dimensions
    function resizeCanvas() {
      const container = document.querySelector('.container');
      const containerRect = container.getBoundingClientRect();
      const availableWidth = containerRect.width - 40; // Account for padding
      const availableHeight = window.innerHeight - 200; // Account for UI elements
      
      // Calculate canvas size maintaining 4:3 aspect ratio
      const aspectRatio = BASE_WIDTH / BASE_HEIGHT;
      let newWidth = Math.min(availableWidth, BASE_WIDTH);
      let newHeight = newWidth / aspectRatio;
      
      // If height is too large, scale based on height instead
      if (newHeight > availableHeight) {
        newHeight = Math.min(availableHeight, BASE_HEIGHT);
        newWidth = newHeight * aspectRatio;
      }
      
      canvasWidth = Math.floor(newWidth);
      canvasHeight = Math.floor(newHeight);
      scale = canvasWidth / BASE_WIDTH;
      
      // Set canvas size
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;
      canvas.style.width = canvasWidth + 'px';
      canvas.style.height = canvasHeight + 'px';
      
      // Recalculate game dimensions based on scale
      PIT_WIDTH = canvasWidth - 10 * scale;
      PIT_X = 5 * scale;
      PIT_Y = canvasHeight - 100 * scale;
      EXIT_WIDTH = 100 * scale;
      EXIT_X = (canvasWidth - EXIT_WIDTH) / 2;
      EXIT_Y = 20 * scale;
      PADDLE_WIDTH = 120 * scale;
      PADDLE_HEIGHT = 15 * scale;
      BALL_RADIUS = 10 * scale;
      
      // Update ball if it exists
      if (ball.radius === 0) {
        ball.x = canvasWidth / 2;
        ball.y = canvasHeight / 2;
        ball.vx = (Math.random() > 0.5 ? 1 : -1) * (3 + Math.random() * 2) * scale;
        ball.vy = (-3 - Math.random() * 2) * scale;
        ball.radius = BALL_RADIUS;
      } else {
        // Scale existing ball position
        ball.x = (ball.x / (canvas.width || BASE_WIDTH)) * canvasWidth;
        ball.y = (ball.y / (canvas.height || BASE_HEIGHT)) * canvasHeight;
        ball.radius = BALL_RADIUS;
        ball.vx = ball.vx > 0 ? Math.abs(ball.vx) * scale : -Math.abs(ball.vx) * scale;
        ball.vy = ball.vy > 0 ? Math.abs(ball.vy) * scale : -Math.abs(ball.vy) * scale;
      }
      
      // Update paddle
      paddle.width = PADDLE_WIDTH;
      paddle.height = PADDLE_HEIGHT;
      paddle.speed = 5 * scale;
      paddle.x = PIT_X + (PIT_WIDTH - PADDLE_WIDTH) / 2;
      paddle.y = PIT_Y - 5 * scale;
      
      // Recalculate walls
      const wallThickness = 5 * scale;
      walls = [
        { x: 0, y: 0, width: canvasWidth, height: wallThickness }, // top
        { x: 0, y: 0, width: wallThickness, height: canvasHeight }, // left
        { x: canvasWidth - wallThickness, y: 0, width: wallThickness, height: canvasHeight }, // right
        { x: 0, y: canvasHeight - wallThickness, width: canvasWidth, height: wallThickness } // bottom
      ];
    }

    // Keyboard controls
    document.addEventListener('keydown', (e) => {
      // Prevent arrow keys from scrolling the page
      if (e.key === 'ArrowUp' || e.key === 'ArrowDown' || 
          e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
        e.preventDefault();
      }
      
      // Ignore up and down arrow keys
      if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
        return;
      }
      
      keys[e.key] = true;
      
      // Spacebar to reset after win or loss
      if (e.key === ' ' && (gameState === 'won' || gameState === 'lost')) {
        e.preventDefault();
        restartGame();
      }
    });

    document.addEventListener('keyup', (e) => {
      // Ignore up and down arrow keys
      if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
        return;
      }
      
      keys[e.key] = false;
    });

    // Restart button
    restartBtn.addEventListener('click', restartGame);

    function restartGame() {
      score = 0;
      gameState = 'playing';
      ball.x = canvasWidth / 2;
      ball.y = canvasHeight / 2;
      ball.vx = (Math.random() > 0.5 ? 1 : -1) * (3 + Math.random() * 2) * scale;
      ball.vy = (-3 - Math.random() * 2) * scale;
      paddle.x = PIT_X + (PIT_WIDTH - PADDLE_WIDTH) / 2;
      statusElement.textContent = 'Use arrow keys to move paddle';
      statusElement.className = 'status';
      updateScore();
    }

    function updateScore() {
      scoreElement.textContent = score;
      winsElement.textContent = wins;
      lossesElement.textContent = losses;
    }

    function updatePaddle() {
      if (gameState !== 'playing') return;

      if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
        paddle.x = Math.max(0, paddle.x - paddle.speed);
      }
      if (keys['ArrowRight'] || keys['d'] || keys['D']) {
        paddle.x = Math.min(canvasWidth - paddle.width, paddle.x + paddle.speed);
      }

      // Keep paddle aligned with pit
      const minX = PIT_X;
      const maxX = PIT_X + PIT_WIDTH - PADDLE_WIDTH;
      paddle.x = Math.max(minX, Math.min(maxX, paddle.x));
    }

    function updateBall() {
      if (gameState !== 'playing') return;

      // Update ball position
      ball.x += ball.vx;
      ball.y += ball.vy;

      // Check collision with walls
      const wallThickness = 5 * scale;
      if (ball.x - ball.radius <= wallThickness) {
        ball.x = wallThickness + ball.radius;
        ball.vx = -ball.vx;
      }
      if (ball.x + ball.radius >= canvasWidth - wallThickness) {
        ball.x = canvasWidth - wallThickness - ball.radius;
        ball.vx = -ball.vx;
      }
      if (ball.y - ball.radius <= wallThickness) {
        ball.y = wallThickness + ball.radius;
        ball.vy = -ball.vy;
      }

      // Check collision with bottom (lose condition)
      if (ball.y + ball.radius >= canvasHeight - wallThickness) {
        gameState = 'lost';
        statusElement.textContent = 'Game Over';
        statusElement.className = 'status lost';
        losses += 1;
        updateScore();
        return;
      }

      // Check collision with paddle
      if (ball.y + ball.radius >= paddle.y &&
          ball.y - ball.radius <= paddle.y + paddle.height &&
          ball.x + ball.radius >= paddle.x &&
          ball.x - ball.radius <= paddle.x + paddle.width) {
        
        // Calculate hit position on paddle (0 = left edge, 1 = right edge)
        const hitPos = (ball.x - paddle.x) / paddle.width;
        
        // Angle based on where ball hits paddle
        // Center = straight up, edges = more angle
        const angle = (hitPos - 0.5) * Math.PI * 0.6; // Max 54 degrees
        const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
        
        // Add some speed boost
        const newSpeed = Math.min(speed * 1.1, 8);
        
        ball.vx = Math.sin(angle) * newSpeed;
        ball.vy = -Math.abs(Math.cos(angle) * newSpeed);
        
        // Ensure ball is above paddle
        ball.y = paddle.y - ball.radius;
        
        score += 10;
        updateScore();
      }

      // Check collision with goal posts (before checking win condition)
      const GOAL_POST_WIDTH_CHECK = 8 * scale;
      const GOAL_POST_HEIGHT_CHECK = 30 * scale;
      const leftPostX = EXIT_X - GOAL_POST_WIDTH_CHECK;
      const rightPostX = EXIT_X + EXIT_WIDTH;
      const crossbarY = EXIT_Y;
      const crossbarHeight = GOAL_POST_WIDTH_CHECK;
      
      // Left goal post (vertical post)
      if (ball.x + ball.radius >= leftPostX &&
          ball.x - ball.radius <= EXIT_X &&
          ball.y + ball.radius >= EXIT_Y &&
          ball.y - ball.radius <= EXIT_Y + GOAL_POST_HEIGHT_CHECK) {
        // Determine which side of post was hit
        if (ball.x < EXIT_X) {
          // Hit left side of post
          ball.x = leftPostX - ball.radius;
          ball.vx = -Math.abs(ball.vx); // Bounce left
        } else {
          // Hit right side of post
          ball.x = EXIT_X + ball.radius;
          ball.vx = Math.abs(ball.vx); // Bounce right
        }
      }
      
      // Right goal post (vertical post)
      if (ball.x - ball.radius <= rightPostX + GOAL_POST_WIDTH_CHECK &&
          ball.x + ball.radius >= rightPostX &&
          ball.y + ball.radius >= EXIT_Y &&
          ball.y - ball.radius <= EXIT_Y + GOAL_POST_HEIGHT_CHECK) {
        // Determine which side of post was hit
        if (ball.x < rightPostX) {
          // Hit left side of post
          ball.x = rightPostX - ball.radius;
          ball.vx = -Math.abs(ball.vx); // Bounce left
        } else {
          // Hit right side of post
          ball.x = rightPostX + GOAL_POST_WIDTH_CHECK + ball.radius;
          ball.vx = Math.abs(ball.vx); // Bounce right
        }
      }
      
      // Crossbar (top horizontal bar of goal)
      if (ball.y + ball.radius >= crossbarY &&
          ball.y - ball.radius <= crossbarY + crossbarHeight &&
          ball.x + ball.radius >= leftPostX &&
          ball.x - ball.radius <= rightPostX + GOAL_POST_WIDTH_CHECK &&
          ball.vy < 0) { // Only bounce if moving upward
        // Bounce vertically downward
        ball.y = crossbarY + crossbarHeight + ball.radius;
        ball.vy = Math.abs(ball.vy); // Bounce down
      }

      // Check win condition - ball enters goal (only through the opening, not posts)
      const goalOpeningTop = EXIT_Y + GOAL_POST_WIDTH_CHECK;
      const goalOpeningBottom = goalOpeningTop + 15 * scale;
      if (ball.y - ball.radius <= goalOpeningBottom &&
          ball.y + ball.radius >= goalOpeningTop &&
          ball.x + ball.radius >= EXIT_X &&
          ball.x - ball.radius <= EXIT_X + EXIT_WIDTH) {
        gameState = 'won';
        statusElement.textContent = 'You Scored!';
        statusElement.className = 'status won';
        wins += 1;
        score += 100;
        updateScore();
      }

      // Check lose condition - ball falls into pit
      if (ball.y >= PIT_Y &&
          ball.x >= PIT_X &&
          ball.x <= PIT_X + PIT_WIDTH) {
        gameState = 'lost';
        statusElement.textContent = 'Game Over';
        statusElement.className = 'status lost';
        losses += 1;
        updateScore();
      }
    }

    function draw() {
      // Clear canvas
      ctx.fillStyle = '#0f172a';
      ctx.fillRect(0, 0, canvasWidth, canvasHeight);

      // Draw walls
      ctx.fillStyle = '#334155';
      walls.forEach(wall => {
        ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
      });

      // Draw goal (top) - goal posts and net
      const GOAL_POST_WIDTH = 8 * scale;
      const GOAL_POST_HEIGHT = 30 * scale;
      const GOAL_NET_DEPTH = 25 * scale;
      
      // Draw goal posts (left and right)
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(EXIT_X - GOAL_POST_WIDTH, EXIT_Y, GOAL_POST_WIDTH, GOAL_POST_HEIGHT);
      ctx.fillRect(EXIT_X + EXIT_WIDTH, EXIT_Y, GOAL_POST_WIDTH, GOAL_POST_HEIGHT);
      
      // Draw crossbar
      ctx.fillRect(EXIT_X - GOAL_POST_WIDTH, EXIT_Y, EXIT_WIDTH + GOAL_POST_WIDTH * 2, GOAL_POST_WIDTH);
      
      // Draw goal opening
      ctx.fillStyle = '#0f172a';
      ctx.fillRect(EXIT_X, EXIT_Y + GOAL_POST_WIDTH, EXIT_WIDTH, 15 * scale);
      
      // Draw net (dashed lines for effect)
      ctx.strokeStyle = '#10b981';
      ctx.lineWidth = 2 * scale;
      ctx.setLineDash([3 * scale, 3 * scale]);
      // Vertical net lines
      for (let i = 0; i <= 4; i++) {
        const x = EXIT_X + (EXIT_WIDTH / 4) * i;
        ctx.beginPath();
        ctx.moveTo(x, EXIT_Y + GOAL_POST_WIDTH);
        ctx.lineTo(x, EXIT_Y + GOAL_POST_WIDTH + GOAL_NET_DEPTH);
        ctx.stroke();
      }
      // Horizontal net lines
      for (let i = 1; i <= 3; i++) {
        const y = EXIT_Y + GOAL_POST_WIDTH + (GOAL_NET_DEPTH / 4) * i;
        ctx.beginPath();
        ctx.moveTo(EXIT_X, y);
        ctx.lineTo(EXIT_X + EXIT_WIDTH, y);
        ctx.stroke();
      }
      ctx.setLineDash([]);
      
      // Draw goal label
      ctx.fillStyle = '#10b981';
      ctx.font = `bold ${18 * scale}px Arial`;
      ctx.textAlign = 'center';
      ctx.fillText('GOAL', EXIT_X + EXIT_WIDTH / 2, EXIT_Y - 8 * scale);

      // Draw pit
      ctx.fillStyle = '#7f1d1d';
      ctx.fillRect(PIT_X, PIT_Y, PIT_WIDTH, canvasHeight - PIT_Y);
      ctx.strokeStyle = '#991b1b';
      ctx.lineWidth = 3 * scale;
      ctx.strokeRect(PIT_X, PIT_Y, PIT_WIDTH, canvasHeight - PIT_Y);
      
      // Draw pit label
      ctx.fillStyle = '#ef4444';
      ctx.font = `bold ${16 * scale}px Arial`;
      ctx.textAlign = 'center';
      ctx.fillText('PIT', PIT_X + PIT_WIDTH / 2, PIT_Y - 5 * scale);

      // Draw paddle with rounded ends
      const radius = paddle.height / 2;
      ctx.fillStyle = '#3b82f6';
      ctx.beginPath();
      ctx.moveTo(paddle.x + radius, paddle.y);
      ctx.lineTo(paddle.x + paddle.width - radius, paddle.y);
      ctx.arc(paddle.x + paddle.width - radius, paddle.y + radius, radius, -Math.PI / 2, Math.PI / 2);
      ctx.lineTo(paddle.x + radius, paddle.y + paddle.height);
      ctx.arc(paddle.x + radius, paddle.y + radius, radius, Math.PI / 2, -Math.PI / 2);
      ctx.closePath();
      ctx.fill();
      
      ctx.strokeStyle = '#2563eb';
      ctx.lineWidth = 2 * scale;
      ctx.stroke();

      // Draw ball
      ctx.fillStyle = '#fbbf24';
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#f59e0b';
      ctx.lineWidth = 2 * scale;
      ctx.stroke();

      // Draw ball trail (visual effect)
      ctx.globalAlpha = 0.3;
      ctx.beginPath();
      ctx.arc(ball.x - ball.vx * 2, ball.y - ball.vy * 2, ball.radius * 0.7, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1.0;

      // Draw game-over overlay if game is won or lost
      if (gameState === 'won' || gameState === 'lost') {
        // Draw semi-transparent overlay
        ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);

        // Draw message box background
        const boxWidth = 500 * scale;
        const boxHeight = 150 * scale;
        const boxX = (canvasWidth - boxWidth) / 2;
        const boxY = (canvasHeight - boxHeight) / 2;
        
        ctx.fillStyle = 'rgba(30, 41, 59, 0.95)';
        ctx.strokeStyle = gameState === 'won' ? '#10b981' : '#ef4444';
        ctx.lineWidth = 3 * scale;
        
        // Draw rounded rectangle
        const cornerRadius = 15 * scale;
        ctx.beginPath();
        ctx.moveTo(boxX + cornerRadius, boxY);
        ctx.lineTo(boxX + boxWidth - cornerRadius, boxY);
        ctx.quadraticCurveTo(boxX + boxWidth, boxY, boxX + boxWidth, boxY + cornerRadius);
        ctx.lineTo(boxX + boxWidth, boxY + boxHeight - cornerRadius);
        ctx.quadraticCurveTo(boxX + boxWidth, boxY + boxHeight, boxX + boxWidth - cornerRadius, boxY + boxHeight);
        ctx.lineTo(boxX + cornerRadius, boxY + boxHeight);
        ctx.quadraticCurveTo(boxX, boxY + boxHeight, boxX, boxY + boxHeight - cornerRadius);
        ctx.lineTo(boxX, boxY + cornerRadius);
        ctx.quadraticCurveTo(boxX, boxY, boxX + cornerRadius, boxY);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        // Draw main message
        ctx.fillStyle = gameState === 'won' ? '#10b981' : '#ef4444';
        ctx.font = `bold ${36 * scale}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const mainMessage = gameState === 'won' ? 'You Scored!' : 'Game Over!';
        ctx.fillText(mainMessage, canvasWidth / 2, boxY + 50 * scale);

        // Draw sub-message
        ctx.fillStyle = '#cbd5e1';
        ctx.font = `${18 * scale}px Arial`;
        ctx.fillText('Press SPACE to play again', canvasWidth / 2, boxY + 100 * scale);
      }
    }

    function gameLoop() {
      updatePaddle();
      updateBall();
      draw();
      requestAnimationFrame(gameLoop);
    }

    // Initialize canvas size
    resizeCanvas();
    
    // Handle window resize
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        resizeCanvas();
      }, 100);
    });

    // Start game loop
    gameLoop();
  </script>
</body>
</html>

