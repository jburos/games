<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Pong Escape - Free Kids Game No Ads | Block the Ball Game</title>
<meta name="description" content="Play Pong Escape - a free kids game with no ads! Block the ball from falling and guide it to escape. Safe, fun game for children." />
<meta name="keywords" content="pong escape, kids games, free games, games without ads, ball game, paddle game, kids arcade game, no ads games, safe games for kids" />
<meta name="author" content="Games Collection" />
<meta name="robots" content="index, follow" />
<link rel="canonical" href="https://games.example.com/pong-escape.html" />

<!-- Open Graph / Facebook -->
<meta property="og:type" content="website" />
<meta property="og:url" content="https://games.example.com/pong-escape.html" />
<meta property="og:title" content="Pong Escape - Free Kids Game No Ads" />
<meta property="og:description" content="Play Pong Escape - a free kids game with no ads! Block the ball from falling and guide it to escape. Safe, fun game for children." />
<meta property="og:site_name" content="Games Collection" />

<!-- Twitter -->
<meta property="twitter:card" content="summary" />
<meta property="twitter:url" content="https://games.example.com/pong-escape.html" />
<meta property="twitter:title" content="Pong Escape - Free Kids Game No Ads" />
<meta property="twitter:description" content="Play Pong Escape - a free kids game with no ads! Block the ball from falling and guide it to escape." />

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "VideoGame",
  "name": "Pong Escape",
  "description": "A free online game for kids with no ads. Block the ball from falling into the pit and angle it to escape through the exit opening.",
  "applicationCategory": "Game",
  "operatingSystem": "Web Browser",
  "offers": {
    "@type": "Offer",
    "price": "0",
    "priceCurrency": "USD"
  },
  "audience": {
    "@type": "Audience",
    "audienceType": "Children"
  },
  "gameItem": {
    "@type": "Thing",
    "name": "Pong Escape",
    "description": "Arcade-style ball and paddle game"
  }
}
</script>
<script src="config.js"></script>
<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  body {
    font-family: Arial, sans-serif;
    background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 20px;
    color: white;
  }

  .container {
    background: #1e293b;
    border-radius: 20px;
    padding: 20px;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    max-width: 95vw;
    width: 100%;
    max-height: 95vh;
    display: flex;
    flex-direction: column;
  }

  h1 {
    text-align: center;
    margin-bottom: 15px;
    font-size: clamp(1.5rem, 4vw, 2.5rem);
    background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }

  .game-info {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
    padding: 10px 15px;
    background: #0f172a;
    border-radius: 10px;
    flex-wrap: wrap;
    gap: 10px;
  }

  .score-display {
    display: flex;
    gap: clamp(10px, 2vw, 20px);
    align-items: center;
    flex-wrap: wrap;
  }

  .score, .wins, .losses {
    font-size: clamp(0.9rem, 2vw, 1.2rem);
    font-weight: bold;
  }

  .wins {
    color: #10b981;
  }

  .losses {
    color: #ef4444;
  }

  .status {
    font-size: clamp(0.9rem, 2vw, 1.1rem);
    padding: 8px 16px;
    border-radius: 8px;
    background: #334155;
  }

  .status.won {
    background: #10b981;
    color: white;
  }

  .status.lost {
    background: #ef4444;
    color: white;
  }

  #gameCanvas {
    display: block;
    margin: 0 auto;
    border: 3px solid #334155;
    border-radius: 10px;
    background: #0f172a;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    max-width: 100%;
    height: auto;
    width: 100%;
  }

  .canvas-wrapper {
    width: 100%;
    display: flex;
    justify-content: center;
    margin-bottom: 15px;
  }

  .controls {
    margin-top: 20px;
    text-align: center;
    padding: 15px;
    background: #0f172a;
    border-radius: 10px;
  }

  .controls p {
    margin-bottom: 10px;
    color: #cbd5e1;
  }

  .controls kbd {
    background: #334155;
    padding: 4px 8px;
    border-radius: 4px;
    font-family: monospace;
    font-size: 0.9rem;
    margin: 0 2px;
  }

  button {
    margin-top: 0;
    padding: clamp(8px, 1.5vw, 10px) clamp(16px, 3vw, 20px);
    font-size: clamp(0.85rem, 2vw, 0.95rem);
    background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-weight: bold;
    transition: transform 0.2s, box-shadow 0.2s;
  }

  button:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(59, 130, 246, 0.4);
  }

  button:active {
    transform: translateY(0);
  }

  .instructions {
    margin-top: 15px;
    padding: 15px;
    background: #0f172a;
    border-radius: 10px;
    border-left: 4px solid #3b82f6;
  }

  .instructions h3 {
    margin-bottom: 10px;
    color: #3b82f6;
    font-size: clamp(1rem, 2.5vw, 1.2rem);
  }

  .instructions ul {
    list-style-position: inside;
    color: #cbd5e1;
    line-height: 1.8;
    font-size: clamp(0.85rem, 2vw, 1rem);
  }

  .instructions li {
    margin-bottom: 5px;
  }

  @media (max-width: 768px) {
    .container {
      padding: 15px;
      max-width: 100vw;
    }

    .game-info {
      flex-direction: column;
      align-items: stretch;
    }

    .score-display {
      justify-content: space-around;
    }
  }

  @media (max-height: 700px) {
    .instructions {
      display: none;
    }
  }
</style>
</head>
<body>
  <div class="container">
    <div style="margin-bottom: 15px; text-align: left;">
      <a href="index.html" style="display: inline-block; padding: 8px 16px; background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%); color: white; text-decoration: none; border-radius: 8px; font-size: 0.9rem; font-weight: bold; transition: transform 0.2s, box-shadow 0.2s;" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 5px 15px rgba(59, 130, 246, 0.4)'" onmouseout="this.style.transform=''; this.style.boxShadow=''">‚Üê Back to Home</a>
    </div>
    <h1>üèì Pong Escape</h1>
    
    <div class="game-info">
      <div class="score-display">
        <div class="score">Score: <span id="score">0</span></div>
        <div class="wins">Wins: <span id="wins">0</span></div>
        <div class="losses">Losses: <span id="losses">0</span></div>
      </div>
      <div class="status" id="status">Use arrow keys to move paddle</div>
      <button id="restartBtn">Restart Game</button>
    </div>

    <div class="canvas-wrapper">
      <canvas id="gameCanvas"></canvas>
    </div>

    <div class="controls">
      <div style="display: flex; align-items: center; gap: 15px; flex-wrap: wrap; justify-content: center;">
        <p style="margin: 0;">Use <kbd>‚Üê</kbd> <kbd>‚Üí</kbd> arrow keys to move the paddle</p>
        <div style="display: flex; align-items: center; gap: 10px;">
          <label for="difficultySelect" style="color: #cbd5e1; font-size: clamp(0.85rem, 2vw, 0.95rem);">Difficulty (Blocks):</label>
          <select id="difficultySelect" style="padding: 6px 12px; font-size: clamp(0.85rem, 2vw, 0.95rem); background: #334155; color: white; border: 1px solid #475569; border-radius: 6px; cursor: pointer;">
            <option value="0">Easy (0)</option>
            <option value="3">Medium (3)</option>
            <option value="5">Hard (5)</option>
            <option value="8">Very Hard (8)</option>
            <option value="12">Extreme (12)</option>
          </select>
        </div>
      </div>
    </div>

    <div class="instructions">
      <h3>How to Play</h3>
      <ul>
        <li><strong>Score:</strong> Guide the ball into the goal at the top to score</li>
        <li><strong>Defend:</strong> Use the paddle to prevent the ball from falling into the pit</li>
        <li><strong>Angle:</strong> Hit the ball at different angles to direct it toward the goal</li>
        <li><strong>Difficulty:</strong> Choose the number of blocks to add obstacles. Blocks bounce the ball and add to your score!</li>
        <li><strong>Win:</strong> Ball enters the goal - you scored!</li>
        <li><strong>Lose:</strong> Ball falls into the pit</li>
      </ul>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreElement = document.getElementById('score');
    const winsElement = document.getElementById('wins');
    const lossesElement = document.getElementById('losses');
    const statusElement = document.getElementById('status');
    const restartBtn = document.getElementById('restartBtn');
    const difficultySelect = document.getElementById('difficultySelect');

    // Game state
    let score = 0;
    let wins = 0;
    let losses = 0;
    let gameState = 'playing'; // 'playing', 'won', 'lost'
    let keys = {};

    // Base game dimensions (aspect ratio 4:3)
    const BASE_WIDTH = 800;
    const BASE_HEIGHT = 600;
    let canvasWidth = BASE_WIDTH;
    let canvasHeight = BASE_HEIGHT;
    let scale = 1;

    // Game dimensions (will be calculated based on canvas size)
    let PIT_WIDTH, PIT_X, PIT_Y, EXIT_WIDTH, EXIT_X, EXIT_Y, PADDLE_WIDTH, PADDLE_HEIGHT, BALL_RADIUS;

    // Ball
    let ball = {
      x: 0,
      y: 0,
      vx: 0,
      vy: 0,
      radius: 0
    };

    // Paddle
    let paddle = {
      x: 0,
      y: 0,
      width: 0,
      height: 0,
      speed: 0
    };

    // Walls (boundaries) - will be recalculated on resize
    let walls = [];
    
    // Blocks for difficulty
    let blocks = [];
    let numBlocks = 0;
    const BLOCK_SIZE = 30; // Base block size, will be scaled

    // Cache container reference to avoid repeated DOM queries
    const container = document.querySelector('.container');
    
    // Function to resize canvas and recalculate dimensions
    function resizeCanvas() {
      const containerRect = container.getBoundingClientRect();
      const availableWidth = containerRect.width - 40; // Account for padding
      const availableHeight = window.innerHeight - 200; // Account for UI elements
      
      // Calculate canvas size maintaining 4:3 aspect ratio
      // Limit maximum size for performance
      const MAX_WIDTH = 800;
      const MAX_HEIGHT = 600;
      const aspectRatio = BASE_WIDTH / BASE_HEIGHT;
      let newWidth = Math.min(availableWidth, MAX_WIDTH);
      let newHeight = newWidth / aspectRatio;
      
      // If height is too large, scale based on height instead
      if (newHeight > availableHeight || newHeight > MAX_HEIGHT) {
        newHeight = Math.min(availableHeight, MAX_HEIGHT);
        newWidth = newHeight * aspectRatio;
      }
      
      // Store old dimensions before updating
      const oldWidth = canvasWidth || BASE_WIDTH;
      const oldHeight = canvasHeight || BASE_HEIGHT;
      const oldScale = scale || 1;
      
      canvasWidth = Math.floor(newWidth);
      canvasHeight = Math.floor(newHeight);
      scale = canvasWidth / BASE_WIDTH;
      
      // Handle high-DPI displays - force 1x for performance on all screens
      // This sacrifices some sharpness but ensures consistent performance
      const effectiveDPR = 1;
      
      // Set canvas size (internal resolution = display size for performance)
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;
      
      // Set canvas display size (CSS)
      canvas.style.width = canvasWidth + 'px';
      canvas.style.height = canvasHeight + 'px';
      
      // Reset transform (no scaling needed since we're using 1x)
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      
      // Recalculate game dimensions based on scale
      PIT_WIDTH = canvasWidth - 10 * scale;
      PIT_X = 5 * scale;
      PIT_Y = canvasHeight - 100 * scale;
      EXIT_WIDTH = 100 * scale;
      EXIT_X = (canvasWidth - EXIT_WIDTH) / 2;
      EXIT_Y = 20 * scale;
      PADDLE_WIDTH = 120 * scale;
      PADDLE_HEIGHT = 15 * scale;
      BALL_RADIUS = 10 * scale;
      
      // Update ball if it exists
      if (ball.radius === 0) {
        initializeBall();
      } else {
        // Scale existing ball position using old dimensions
        ball.x = (ball.x / oldWidth) * canvasWidth;
        ball.y = (ball.y / oldHeight) * canvasHeight;
        ball.radius = BALL_RADIUS;
        ball.vx = (ball.vx / oldScale) * scale;
        ball.vy = (ball.vy / oldScale) * scale;
      }
      
      // Update paddle
      paddle.width = PADDLE_WIDTH;
      paddle.height = PADDLE_HEIGHT;
      paddle.speed = 5 * scale;
      paddle.x = PIT_X + (PIT_WIDTH - PADDLE_WIDTH) / 2;
      paddle.y = PIT_Y - 5 * scale;
      
      // Recalculate walls
      const wallThickness = 5 * scale;
      walls = [
        { x: 0, y: 0, width: canvasWidth, height: wallThickness }, // top
        { x: 0, y: 0, width: wallThickness, height: canvasHeight }, // left
        { x: canvasWidth - wallThickness, y: 0, width: wallThickness, height: canvasHeight }, // right
        { x: 0, y: canvasHeight - wallThickness, width: canvasWidth, height: wallThickness } // bottom
      ];
      
      // Regenerate blocks if they exist
      if (blocks.length > 0) {
        generateBlocks(numBlocks);
      }
    }

    // Keyboard controls
    document.addEventListener('keydown', (e) => {
      // Prevent arrow keys from scrolling the page
      if (e.key === 'ArrowUp' || e.key === 'ArrowDown' || 
          e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
        e.preventDefault();
      }
      
      // Ignore up and down arrow keys
      if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
        return;
      }
      
      keys[e.key] = true;
      
      // Spacebar to reset after win or loss
      if (e.key === ' ' && (gameState === 'won' || gameState === 'lost')) {
        e.preventDefault();
        restartGame();
      }
    });

    document.addEventListener('keyup', (e) => {
      // Ignore up and down arrow keys
      if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
        return;
      }
      
      keys[e.key] = false;
    });

    // Function to initialize ball at random position moving towards closest wall
    function initializeBall() {
      const wallThickness = 5 * scale;
      const margin = 50 * scale; // Keep ball away from edges
      
      // Random position (avoid edges and goal/pit areas)
      const minX = margin + BALL_RADIUS;
      const maxX = canvasWidth - margin - BALL_RADIUS;
      const minY = margin + BALL_RADIUS + (30 * scale); // Below goal area
      const maxY = canvasHeight - margin - BALL_RADIUS - (100 * scale); // Above pit area
      
      ball.x = minX + Math.random() * (maxX - minX);
      ball.y = minY + Math.random() * (maxY - minY);
      
      // Calculate distances to each wall (excluding top/goal)
      const distToTop = ball.y - wallThickness;
      const distToLeft = ball.x - wallThickness;
      const distToRight = canvasWidth - wallThickness - ball.x;
      const distToBottom = canvasHeight - wallThickness - ball.y;
      
      // Find the closest wall (excluding top/goal)
      const distances = [
        { wall: 'left', dist: distToLeft },
        { wall: 'right', dist: distToRight },
        { wall: 'bottom', dist: distToBottom }
      ];
      
      const closestWall = distances.reduce((min, current) => 
        current.dist < min.dist ? current : min
      );
      
      // Set velocity towards the closest wall (never towards goal/top)
      // Ensure angle is never too close to horizontal (minimum 30 degrees from horizontal)
      const baseSpeed = (3 + Math.random() * 2) * scale;
      const minVerticalRatio = 0.5; // Minimum vertical/horizontal ratio (tan of ~30 degrees)
      
      switch(closestWall.wall) {
        case 'left': // Move towards left wall
          // Ensure significant vertical component (at least 50% of horizontal)
          const leftVertical = (0.5 + Math.random() * 0.5) * baseSpeed * minVerticalRatio;
          ball.vx = -baseSpeed; // Move left
          ball.vy = (Math.random() > 0.5 ? 1 : -1) * leftVertical; // Vertical component
          break;
        case 'right': // Move towards right wall
          // Ensure significant vertical component (at least 50% of horizontal)
          const rightVertical = (0.5 + Math.random() * 0.5) * baseSpeed * minVerticalRatio;
          ball.vx = baseSpeed; // Move right
          ball.vy = (Math.random() > 0.5 ? 1 : -1) * rightVertical; // Vertical component
          break;
        case 'bottom': // Move towards bottom wall
          // Ensure significant horizontal component (at least 50% of vertical)
          const bottomHorizontal = (0.5 + Math.random() * 0.5) * baseSpeed * minVerticalRatio;
          ball.vx = (Math.random() > 0.5 ? 1 : -1) * bottomHorizontal; // Horizontal component
          ball.vy = baseSpeed; // Move down
          break;
      }
      
      ball.radius = BALL_RADIUS;
    }

    // Function to generate random blocks
    function generateBlocks(count) {
      blocks = [];
      numBlocks = count;
      
      if (count === 0) return;
      
      const blockSize = BLOCK_SIZE * scale;
      const wallThickness = 5 * scale;
      const minDistanceFromPaddle = 80 * scale; // Keep blocks away from paddle
      const minDistanceFromGoal = 20 * scale; // Can be closer to goal
      
      // Define playable area (avoid walls, paddle area, and goal area)
      const playableTop = EXIT_Y + 50 * scale; // Below goal area
      const playableBottom = PIT_Y - minDistanceFromPaddle; // Above paddle area
      const playableLeft = wallThickness + blockSize;
      const playableRight = canvasWidth - wallThickness - blockSize;
      
      const maxAttempts = count * 50; // Limit attempts to avoid infinite loops
      let attempts = 0;
      
      while (blocks.length < count && attempts < maxAttempts) {
        attempts++;
        
        // Random position in playable area
        const x = playableLeft + Math.random() * (playableRight - playableLeft);
        const y = playableTop + Math.random() * (playableBottom - playableTop);
        
        // Check if this position overlaps with existing blocks
        let overlaps = false;
        const minBlockDistance = blockSize * 1.5; // Minimum distance between blocks
        
        for (const block of blocks) {
          const dx = x - block.x;
          const dy = y - block.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          if (distance < minBlockDistance) {
            overlaps = true;
            break;
          }
        }
        
        // Also check distance from paddle
        const paddleCenterX = paddle.x + paddle.width / 2;
        const paddleCenterY = paddle.y;
        const dxToPaddle = x - paddleCenterX;
        const dyToPaddle = y - paddleCenterY;
        const distanceToPaddle = Math.sqrt(dxToPaddle * dxToPaddle + dyToPaddle * dyToPaddle);
        
        if (!overlaps && distanceToPaddle >= minDistanceFromPaddle) {
          // Randomly assign shape type
          const shapeType = Math.random();
          let block;
          
          if (shapeType < 0.4) {
            // Square (40% chance)
            block = { 
              x, 
              y, 
              width: blockSize, 
              height: blockSize,
              shape: 'square'
            };
          } else if (shapeType < 0.75) {
            // Rectangle (35% chance) - can be horizontal or vertical
            const isHorizontal = Math.random() > 0.5;
            block = {
              x,
              y,
              width: isHorizontal ? blockSize * 1.5 : blockSize,
              height: isHorizontal ? blockSize : blockSize * 1.5,
              shape: 'rectangle'
            };
          } else {
            // Triangle (25% chance)
            block = {
              x,
              y,
              width: blockSize,
              height: blockSize,
              shape: 'triangle',
              // Triangle vertices (pointing up, down, left, or right)
              orientation: Math.floor(Math.random() * 4) // 0=up, 1=down, 2=left, 3=right
            };
          }
          
          blocks.push(block);
        }
      }
    }
    
    // Difficulty selector
    difficultySelect.addEventListener('change', (e) => {
      const newNumBlocks = parseInt(e.target.value);
      generateBlocks(newNumBlocks);
      if (gameState === 'playing') {
        // If game is in progress, restart to apply new difficulty
        restartGame();
      }
    });

    // Restart button
    restartBtn.addEventListener('click', restartGame);

    function restartGame() {
      score = 0;
      gameState = 'playing';
      initializeBall();
      paddle.x = PIT_X + (PIT_WIDTH - PADDLE_WIDTH) / 2;
      // Regenerate blocks with current difficulty setting
      const currentDifficulty = parseInt(difficultySelect.value);
      generateBlocks(currentDifficulty);
      statusElement.textContent = 'Use arrow keys to move paddle';
      statusElement.className = 'status';
      updateScore();
    }

    function updateScore() {
      scoreElement.textContent = score;
      winsElement.textContent = wins;
      lossesElement.textContent = losses;
    }

    function updatePaddle() {
      if (gameState !== 'playing') return;

      if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
        paddle.x = Math.max(0, paddle.x - paddle.speed);
      }
      if (keys['ArrowRight'] || keys['d'] || keys['D']) {
        paddle.x = Math.min(canvasWidth - paddle.width, paddle.x + paddle.speed);
      }

      // Keep paddle aligned with pit
      const minX = PIT_X;
      const maxX = PIT_X + PIT_WIDTH - PADDLE_WIDTH;
      paddle.x = Math.max(minX, Math.min(maxX, paddle.x));
    }

    function updateBall() {
      if (gameState !== 'playing') return;

      // Update ball position
      ball.x += ball.vx;
      ball.y += ball.vy;

      // Check collision with walls
      const wallThickness = 5 * scale;
      if (ball.x - ball.radius <= wallThickness) {
        ball.x = wallThickness + ball.radius;
        ball.vx = -ball.vx;
      }
      if (ball.x + ball.radius >= canvasWidth - wallThickness) {
        ball.x = canvasWidth - wallThickness - ball.radius;
        ball.vx = -ball.vx;
      }
      if (ball.y - ball.radius <= wallThickness) {
        ball.y = wallThickness + ball.radius;
        ball.vy = -ball.vy;
      }

      // Check collision with bottom (lose condition)
      if (ball.y + ball.radius >= canvasHeight - wallThickness) {
        gameState = 'lost';
        statusElement.textContent = 'Game Over';
        statusElement.className = 'status lost';
        losses += 1;
        updateScore();
        return;
      }

      // Check collision with blocks
      for (const block of blocks) {
        let collided = false;
        let collisionSide = null;
        
        if (block.shape === 'triangle') {
          // Triangle collision detection
          const cx = block.x + block.width / 2;
          const cy = block.y + block.height / 2;
          
          let p1, p2, p3;
          
          // Get triangle vertices based on orientation
          switch (block.orientation) {
            case 0: // Pointing up
              p1 = { x: cx, y: block.y };
              p2 = { x: block.x, y: block.y + block.height };
              p3 = { x: block.x + block.width, y: block.y + block.height };
              break;
            case 1: // Pointing down
              p1 = { x: cx, y: block.y + block.height };
              p2 = { x: block.x, y: block.y };
              p3 = { x: block.x + block.width, y: block.y };
              break;
            case 2: // Pointing left
              p1 = { x: block.x, y: cy };
              p2 = { x: block.x + block.width, y: block.y };
              p3 = { x: block.x + block.width, y: block.y + block.height };
              break;
            case 3: // Pointing right
              p1 = { x: block.x + block.width, y: cy };
              p2 = { x: block.x, y: block.y };
              p3 = { x: block.x, y: block.y + block.height };
              break;
          }
          
          // Check if ball center is inside triangle (simple AABB check first)
          const ballLeft = ball.x - ball.radius;
          const ballRight = ball.x + ball.radius;
          const ballTop = ball.y - ball.radius;
          const ballBottom = ball.y + ball.radius;
          
          const blockLeft = block.x;
          const blockRight = block.x + block.width;
          const blockTop = block.y;
          const blockBottom = block.y + block.height;
          
          if (ballRight > blockLeft && ballLeft < blockRight &&
              ballBottom > blockTop && ballTop < blockBottom) {
            // Check distance from ball to triangle edges
            const distToP1 = Math.sqrt((ball.x - p1.x) ** 2 + (ball.y - p1.y) ** 2);
            const distToP2 = Math.sqrt((ball.x - p2.x) ** 2 + (ball.y - p2.y) ** 2);
            const distToP3 = Math.sqrt((ball.x - p3.x) ** 2 + (ball.y - p3.y) ** 2);
            
            // Check if ball is close enough to triangle (within radius)
            const minDist = Math.min(distToP1, distToP2, distToP3);
            if (minDist < ball.radius * 1.5) {
              collided = true;
              // Determine collision side based on which edge is closest
              const dx = ball.x - cx;
              const dy = ball.y - cy;
              
              if (block.orientation === 0) { // Pointing up
                if (dy < 0) collisionSide = 'top';
                else if (Math.abs(dx) > Math.abs(dy)) collisionSide = dx < 0 ? 'left' : 'right';
                else collisionSide = 'bottom';
              } else if (block.orientation === 1) { // Pointing down
                if (dy > 0) collisionSide = 'bottom';
                else if (Math.abs(dx) > Math.abs(dy)) collisionSide = dx < 0 ? 'left' : 'right';
                else collisionSide = 'top';
              } else if (block.orientation === 2) { // Pointing left
                if (dx < 0) collisionSide = 'left';
                else if (Math.abs(dy) > Math.abs(dx)) collisionSide = dy < 0 ? 'top' : 'bottom';
                else collisionSide = 'right';
              } else { // Pointing right
                if (dx > 0) collisionSide = 'right';
                else if (Math.abs(dy) > Math.abs(dx)) collisionSide = dy < 0 ? 'top' : 'bottom';
                else collisionSide = 'left';
              }
            }
          }
        } else {
          // Square/Rectangle collision detection
          const ballLeft = ball.x - ball.radius;
          const ballRight = ball.x + ball.radius;
          const ballTop = ball.y - ball.radius;
          const ballBottom = ball.y + ball.radius;
          
          const blockLeft = block.x;
          const blockRight = block.x + block.width;
          const blockTop = block.y;
          const blockBottom = block.y + block.height;
          
          if (ballRight > blockLeft && ballLeft < blockRight &&
              ballBottom > blockTop && ballTop < blockBottom) {
            collided = true;
            
            // Determine collision side
            const overlapLeft = ballRight - blockLeft;
            const overlapRight = blockRight - ballLeft;
            const overlapTop = ballBottom - blockTop;
            const overlapBottom = blockBottom - ballTop;
            
            // Find minimum overlap to determine collision side
            const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);
            
            if (minOverlap === overlapLeft) {
              collisionSide = 'left';
            } else if (minOverlap === overlapRight) {
              collisionSide = 'right';
            } else if (minOverlap === overlapTop) {
              collisionSide = 'top';
            } else {
              collisionSide = 'bottom';
            }
          }
        }
        
        if (collided) {
          // Handle collision based on side
          const blockLeft = block.x;
          const blockRight = block.x + block.width;
          const blockTop = block.y;
          const blockBottom = block.y + block.height;
          
          if (collisionSide === 'left') {
            ball.x = blockLeft - ball.radius;
            ball.vx = -Math.abs(ball.vx);
          } else if (collisionSide === 'right') {
            ball.x = blockRight + ball.radius;
            ball.vx = Math.abs(ball.vx);
          } else if (collisionSide === 'top') {
            ball.y = blockTop - ball.radius;
            ball.vy = -Math.abs(ball.vy);
          } else if (collisionSide === 'bottom') {
            ball.y = blockBottom + ball.radius;
            ball.vy = Math.abs(ball.vy);
          }
          
          // Add some speed variation on block hit
          const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
          const speedVariation = 0.9 + Math.random() * 0.2; // 90-110% of current speed
          ball.vx *= speedVariation;
          ball.vy *= speedVariation;
          
          score += 5; // Small score bonus for hitting blocks
          updateScore();
          break; // Only handle one collision per frame
        }
      }

      // Check collision with paddle
      if (ball.y + ball.radius >= paddle.y &&
          ball.y - ball.radius <= paddle.y + paddle.height &&
          ball.x + ball.radius >= paddle.x &&
          ball.x - ball.radius <= paddle.x + paddle.width) {
        
        // Calculate hit position on paddle (0 = left edge, 1 = right edge)
        const hitPos = (ball.x - paddle.x) / paddle.width;
        
        // Angle based on where ball hits paddle
        // Center = straight up, edges = more angle
        const angle = (hitPos - 0.5) * Math.PI * 0.6; // Max 54 degrees
        const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
        
        // Add some speed boost
        const newSpeed = Math.min(speed * 1.1, 8);
        
        ball.vx = Math.sin(angle) * newSpeed;
        ball.vy = -Math.abs(Math.cos(angle) * newSpeed);
        
        // Ensure ball is above paddle
        ball.y = paddle.y - ball.radius;
        
        score += 10;
        updateScore();
      }

      // Check collision with goal posts (before checking win condition)
      const GOAL_POST_WIDTH_CHECK = 8 * scale;
      const GOAL_POST_HEIGHT_CHECK = 30 * scale;
      const leftPostX = EXIT_X - GOAL_POST_WIDTH_CHECK;
      const rightPostX = EXIT_X + EXIT_WIDTH;
      const crossbarY = EXIT_Y;
      const crossbarHeight = GOAL_POST_WIDTH_CHECK;
      
      // Left goal post (vertical post)
      if (ball.x + ball.radius >= leftPostX &&
          ball.x - ball.radius <= EXIT_X &&
          ball.y + ball.radius >= EXIT_Y &&
          ball.y - ball.radius <= EXIT_Y + GOAL_POST_HEIGHT_CHECK) {
        // Determine which side of post was hit
        if (ball.x < EXIT_X) {
          // Hit left side of post
          ball.x = leftPostX - ball.radius;
          ball.vx = -Math.abs(ball.vx); // Bounce left
        } else {
          // Hit right side of post
          ball.x = EXIT_X + ball.radius;
          ball.vx = Math.abs(ball.vx); // Bounce right
        }
      }
      
      // Right goal post (vertical post)
      if (ball.x - ball.radius <= rightPostX + GOAL_POST_WIDTH_CHECK &&
          ball.x + ball.radius >= rightPostX &&
          ball.y + ball.radius >= EXIT_Y &&
          ball.y - ball.radius <= EXIT_Y + GOAL_POST_HEIGHT_CHECK) {
        // Determine which side of post was hit
        if (ball.x < rightPostX) {
          // Hit left side of post
          ball.x = rightPostX - ball.radius;
          ball.vx = -Math.abs(ball.vx); // Bounce left
        } else {
          // Hit right side of post
          ball.x = rightPostX + GOAL_POST_WIDTH_CHECK + ball.radius;
          ball.vx = Math.abs(ball.vx); // Bounce right
        }
      }
      
      // Crossbar (top horizontal bar of goal)
      if (ball.y + ball.radius >= crossbarY &&
          ball.y - ball.radius <= crossbarY + crossbarHeight &&
          ball.x + ball.radius >= leftPostX &&
          ball.x - ball.radius <= rightPostX + GOAL_POST_WIDTH_CHECK &&
          ball.vy < 0) { // Only bounce if moving upward
        // Bounce vertically downward
        ball.y = crossbarY + crossbarHeight + ball.radius;
        ball.vy = Math.abs(ball.vy); // Bounce down
      }

      // Check win condition - ball enters goal (only through the opening, not posts)
      const goalOpeningTop = EXIT_Y + GOAL_POST_WIDTH_CHECK;
      const goalOpeningBottom = goalOpeningTop + 15 * scale;
      if (ball.y - ball.radius <= goalOpeningBottom &&
          ball.y + ball.radius >= goalOpeningTop &&
          ball.x + ball.radius >= EXIT_X &&
          ball.x - ball.radius <= EXIT_X + EXIT_WIDTH) {
        gameState = 'won';
        statusElement.textContent = 'You Scored!';
        statusElement.className = 'status won';
        wins += 1;
        score += 100;
        updateScore();
      }

      // Check lose condition - ball falls into pit
      if (ball.y >= PIT_Y &&
          ball.x >= PIT_X &&
          ball.x <= PIT_X + PIT_WIDTH) {
        gameState = 'lost';
        statusElement.textContent = 'Game Over';
        statusElement.className = 'status lost';
        losses += 1;
        updateScore();
      }
    }

    function draw() {
      // Clear canvas
      ctx.fillStyle = '#0f172a';
      ctx.fillRect(0, 0, canvasWidth, canvasHeight);

      // Draw walls
      ctx.fillStyle = '#334155';
      walls.forEach(wall => {
        ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
      });

      // Draw goal (top) - goal posts and net
      const GOAL_POST_WIDTH = 8 * scale;
      const GOAL_POST_HEIGHT = 30 * scale;
      const GOAL_NET_DEPTH = 25 * scale;
      
      // Draw goal posts (left and right)
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(EXIT_X - GOAL_POST_WIDTH, EXIT_Y, GOAL_POST_WIDTH, GOAL_POST_HEIGHT);
      ctx.fillRect(EXIT_X + EXIT_WIDTH, EXIT_Y, GOAL_POST_WIDTH, GOAL_POST_HEIGHT);
      
      // Draw crossbar
      ctx.fillRect(EXIT_X - GOAL_POST_WIDTH, EXIT_Y, EXIT_WIDTH + GOAL_POST_WIDTH * 2, GOAL_POST_WIDTH);
      
      // Draw goal opening
      ctx.fillStyle = '#0f172a';
      ctx.fillRect(EXIT_X, EXIT_Y + GOAL_POST_WIDTH, EXIT_WIDTH, 15 * scale);
      
      // Draw simplified net (fewer lines for better performance)
      ctx.strokeStyle = '#10b981';
      ctx.lineWidth = 2 * scale;
      ctx.setLineDash([3 * scale, 3 * scale]);
      ctx.beginPath();
      // Reduced net lines for performance
      // Vertical net lines (fewer)
      for (let i = 0; i <= 2; i++) {
        const x = EXIT_X + (EXIT_WIDTH / 2) * i;
        ctx.moveTo(x, EXIT_Y + GOAL_POST_WIDTH);
        ctx.lineTo(x, EXIT_Y + GOAL_POST_WIDTH + GOAL_NET_DEPTH);
      }
      // Horizontal net lines (fewer)
      for (let i = 1; i <= 2; i++) {
        const y = EXIT_Y + GOAL_POST_WIDTH + (GOAL_NET_DEPTH / 3) * i;
        ctx.moveTo(EXIT_X, y);
        ctx.lineTo(EXIT_X + EXIT_WIDTH, y);
      }
      ctx.stroke();
      ctx.setLineDash([]);

      // Draw blocks
      ctx.fillStyle = '#8b5cf6';
      ctx.strokeStyle = '#6d28d9';
      ctx.lineWidth = 2 * scale;
      blocks.forEach(block => {
        ctx.beginPath();
        
        if (block.shape === 'triangle') {
          // Draw triangle based on orientation
          const cx = block.x + block.width / 2;
          const cy = block.y + block.height / 2;
          
          switch (block.orientation) {
            case 0: // Pointing up
              ctx.moveTo(cx, block.y);
              ctx.lineTo(block.x, block.y + block.height);
              ctx.lineTo(block.x + block.width, block.y + block.height);
              break;
            case 1: // Pointing down
              ctx.moveTo(cx, block.y + block.height);
              ctx.lineTo(block.x, block.y);
              ctx.lineTo(block.x + block.width, block.y);
              break;
            case 2: // Pointing left
              ctx.moveTo(block.x, cy);
              ctx.lineTo(block.x + block.width, block.y);
              ctx.lineTo(block.x + block.width, block.y + block.height);
              break;
            case 3: // Pointing right
              ctx.moveTo(block.x + block.width, cy);
              ctx.lineTo(block.x, block.y);
              ctx.lineTo(block.x, block.y + block.height);
              break;
          }
          ctx.closePath();
        } else {
          // Draw square or rectangle with rounded corners
          const cornerRadius = 4 * scale;
          ctx.moveTo(block.x + cornerRadius, block.y);
          ctx.lineTo(block.x + block.width - cornerRadius, block.y);
          ctx.quadraticCurveTo(block.x + block.width, block.y, block.x + block.width, block.y + cornerRadius);
          ctx.lineTo(block.x + block.width, block.y + block.height - cornerRadius);
          ctx.quadraticCurveTo(block.x + block.width, block.y + block.height, block.x + block.width - cornerRadius, block.y + block.height);
          ctx.lineTo(block.x + cornerRadius, block.y + block.height);
          ctx.quadraticCurveTo(block.x, block.y + block.height, block.x, block.y + block.height - cornerRadius);
          ctx.lineTo(block.x, block.y + cornerRadius);
          ctx.quadraticCurveTo(block.x, block.y, block.x + cornerRadius, block.y);
          ctx.closePath();
        }
        
        ctx.fill();
        ctx.stroke();
      });

      // Draw pit
      ctx.fillStyle = '#7f1d1d';
      ctx.fillRect(PIT_X, PIT_Y, PIT_WIDTH, canvasHeight - PIT_Y);
      ctx.strokeStyle = '#991b1b';
      ctx.lineWidth = 3 * scale;
      ctx.strokeRect(PIT_X, PIT_Y, PIT_WIDTH, canvasHeight - PIT_Y);

      // Draw paddle with rounded ends
      const radius = paddle.height / 2;
      ctx.fillStyle = '#3b82f6';
      ctx.beginPath();
      ctx.moveTo(paddle.x + radius, paddle.y);
      ctx.lineTo(paddle.x + paddle.width - radius, paddle.y);
      ctx.arc(paddle.x + paddle.width - radius, paddle.y + radius, radius, -Math.PI / 2, Math.PI / 2);
      ctx.lineTo(paddle.x + radius, paddle.y + paddle.height);
      ctx.arc(paddle.x + radius, paddle.y + radius, radius, Math.PI / 2, -Math.PI / 2);
      ctx.closePath();
      ctx.fill();
      
      ctx.strokeStyle = '#2563eb';
      ctx.lineWidth = 2 * scale;
      ctx.stroke();

      // Draw ball
      ctx.fillStyle = '#fbbf24';
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#f59e0b';
      ctx.lineWidth = 2 * scale;
      ctx.stroke();

      // Ball trail removed for better performance

      // Draw game-over overlay if game is won or lost
      if (gameState === 'won' || gameState === 'lost') {
        // Draw semi-transparent overlay
        ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);

        // Draw message box background
        const boxWidth = 500 * scale;
        const boxHeight = 150 * scale;
        const boxX = (canvasWidth - boxWidth) / 2;
        const boxY = (canvasHeight - boxHeight) / 2;
        
        ctx.fillStyle = 'rgba(30, 41, 59, 0.95)';
        ctx.strokeStyle = gameState === 'won' ? '#10b981' : '#ef4444';
        ctx.lineWidth = 3 * scale;
        
        // Draw rounded rectangle
        const cornerRadius = 15 * scale;
        ctx.beginPath();
        ctx.moveTo(boxX + cornerRadius, boxY);
        ctx.lineTo(boxX + boxWidth - cornerRadius, boxY);
        ctx.quadraticCurveTo(boxX + boxWidth, boxY, boxX + boxWidth, boxY + cornerRadius);
        ctx.lineTo(boxX + boxWidth, boxY + boxHeight - cornerRadius);
        ctx.quadraticCurveTo(boxX + boxWidth, boxY + boxHeight, boxX + boxWidth - cornerRadius, boxY + boxHeight);
        ctx.lineTo(boxX + cornerRadius, boxY + boxHeight);
        ctx.quadraticCurveTo(boxX, boxY + boxHeight, boxX, boxY + boxHeight - cornerRadius);
        ctx.lineTo(boxX, boxY + cornerRadius);
        ctx.quadraticCurveTo(boxX, boxY, boxX + cornerRadius, boxY);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        // Draw main message
        ctx.fillStyle = gameState === 'won' ? '#10b981' : '#ef4444';
        ctx.font = `bold ${36 * scale}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const mainMessage = gameState === 'won' ? 'You Scored!' : 'Game Over!';
        ctx.fillText(mainMessage, canvasWidth / 2, boxY + 50 * scale);

        // Draw sub-message
        ctx.fillStyle = '#cbd5e1';
        ctx.font = `${18 * scale}px Arial`;
        ctx.fillText('Press SPACE to play again', canvasWidth / 2, boxY + 100 * scale);
      }
    }

    let frameCount = 0;
    function gameLoop() {
      // Only update physics every frame, but optimize drawing
      updatePaddle();
      updateBall();
      
      // Draw every frame (required for smooth animation)
      draw();
      
      requestAnimationFrame(gameLoop);
    }

    // Initialize canvas size
    resizeCanvas();
    
    // Initialize blocks with default difficulty (after canvas is resized)
    setTimeout(() => {
      generateBlocks(parseInt(difficultySelect.value));
    }, 0);
    
    // Handle window resize - increased debounce time for better performance
    let resizeTimeout;
    let lastWidth = 0;
    let lastHeight = 0;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        const currentWidth = window.innerWidth;
        const currentHeight = window.innerHeight;
        // Only resize if there's a meaningful change
        if (Math.abs(currentWidth - lastWidth) > 10 || Math.abs(currentHeight - lastHeight) > 10) {
          lastWidth = currentWidth;
          lastHeight = currentHeight;
          resizeCanvas();
        }
      }, 250);
    });

    // Start game loop
    gameLoop();
  </script>
</body>
</html>

