<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Tiling Puzzle - Free Kids Game No Ads | Shape Puzzle Game</title>
<meta name="description" content="Play Tiling Puzzle for free! Kids game with no ads. Place L, S, and T shapes on a grid to completely fill it. Rotate and flip shapes, drag and drop to solve the puzzle." />
<meta name="keywords" content="tiling puzzle, puzzle games, kids games, free games, games without ads, shape puzzle, logic puzzle, no ads games, safe games for kids, educational puzzle games" />
<meta name="author" content="Games Collection" />
<meta name="robots" content="index, follow" />
<link rel="canonical" href="https://games.example.com/tiling.html" />

<!-- Open Graph / Facebook -->
<meta property="og:type" content="website" />
<meta property="og:url" content="https://games.example.com/tiling.html" />
<meta property="og:title" content="Tiling Puzzle - Free Kids Game No Ads" />
<meta property="og:description" content="Play Tiling Puzzle for free! Kids game with no ads. Place L, S, and T shapes on a grid to completely fill it. Rotate and flip shapes to solve the puzzle." />
<meta property="og:site_name" content="Games Collection" />

<!-- Twitter -->
<meta property="twitter:card" content="summary" />
<meta property="twitter:url" content="https://games.example.com/tiling.html" />
<meta property="twitter:title" content="Tiling Puzzle - Free Kids Game No Ads" />
<meta property="twitter:description" content="Play Tiling Puzzle for free! Kids game with no ads. Place shapes on a grid to completely fill it." />

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "VideoGame",
  "name": "Tiling Puzzle",
  "description": "A free online tiling puzzle game for kids with no ads. Place L, S, and T shapes on a grid to completely fill it. Rotate and flip shapes, drag and drop to solve the puzzle.",
  "applicationCategory": "Game",
  "operatingSystem": "Web Browser",
  "gameGenre": "Puzzle",
  "offers": {
    "@type": "Offer",
    "price": "0",
    "priceCurrency": "USD"
  },
  "audience": {
    "@type": "Audience",
    "audienceType": "Children"
  },
  "gameItem": {
    "@type": "Thing",
    "name": "Tiling Puzzle",
    "description": "Shape-based tiling puzzle game"
  }
}
</script>
<style>
  body {
    font-family: Arial, sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    margin-top: 20px;
    background: #f5f5f5;
  }

  h1 {
    margin-bottom: 20px;
    color: #333;
  }

  #controls {
    margin-bottom: 20px;
    display: flex;
    gap: 15px;
    align-items: center;
    flex-wrap: wrap;
    justify-content: center;
  }

  #rotationControls {
    display: flex;
    gap: 10px;
  }

  #rotationControls button {
    padding: 6px 12px;
    font-size: 0.9rem;
    background: #6b7280;
  }

  #rotationControls button:hover {
    background: #4b5563;
  }

  label {
    font-size: 1rem;
  }

  select, button {
    padding: 8px 12px;
    font-size: 1rem;
    border: 1px solid #ccc;
    border-radius: 4px;
    background: white;
    cursor: pointer;
  }

  button {
    background: #2563eb;
    color: white;
    border: none;
    font-weight: bold;
  }

  button:hover {
    background: #1d4ed8;
  }

  button:disabled {
    background: #ccc;
    cursor: not-allowed;
  }

  #gameContainer {
    display: flex;
    gap: 30px;
    justify-content: center;
    align-items: flex-start;
    flex-wrap: wrap;
  }

  #shapePreview {
    padding: 20px;
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    min-width: 150px;
    cursor: grab;
    user-select: none;
  }

  .shape-option {
    padding: 15px;
    margin: 10px;
    background: #f0f0f0;
    border-radius: 8px;
    border: 2px solid transparent;
    cursor: pointer;
    transition: all 0.2s;
    display: inline-block;
  }

  .shape-option:hover {
    background: #e0e0e0;
    border-color: #2563eb;
  }

  .shape-option.active {
    background: #e0e7ff;
    border-color: #2563eb;
  }

  .shape-option h4 {
    margin: 0 0 10px 0;
    font-size: 0.9rem;
    color: #333;
    text-align: center;
  }

  #shapePreview:active {
    cursor: grabbing;
  }

  #shapePreview h3 {
    margin: 0 0 15px 0;
    font-size: 1.1rem;
    color: #333;
    text-align: center;
  }

  #shapePreview.dragging {
    opacity: 0.5;
  }

  .drag-ghost {
    position: fixed;
    pointer-events: none;
    z-index: 10000;
    opacity: 0.8;
    transform: translate(-50%, -50%);
  }

  #shapePreviewGrid {
    display: grid;
    gap: 3px;
    padding: 15px;
    background: #e5e5e5;
    border-radius: 4px;
    justify-content: center;
  }

  .preview-shape-cell {
    width: 30px;
    height: 30px;
    background: #2563eb;
    border-radius: 2px;
  }

  .preview-shape-cell.empty {
    background: transparent;
  }

  #board {
    display: grid;
    gap: 2px;
    background: #333;
    padding: 2px;
    border-radius: 4px;
  }

  .board-cell {
    background: white;
    border-radius: 2px;
    transition: background 0.2s;
  }

  .board-cell:hover {
    background: #e0e7ff;
  }

  .board-cell.filled {
    background: #2563eb;
  }

  .board-cell.filled-1 { background: #2563eb !important; }
  .board-cell.filled-2 { background: #dc2626 !important; }
  .board-cell.filled-3 { background: #16a34a !important; }
  .board-cell.filled-4 { background: #ca8a04 !important; }
  .board-cell.filled-5 { background: #9333ea !important; }
  .board-cell.filled-6 { background: #ea580c !important; }
  .board-cell.filled-7 { background: #0891b2 !important; }
  .board-cell.filled-8 { background: #be123c !important; }

  .board-cell.filled-1:hover,
  .board-cell.filled-2:hover,
  .board-cell.filled-3:hover,
  .board-cell.filled-4:hover,
  .board-cell.filled-5:hover,
  .board-cell.filled-6:hover,
  .board-cell.filled-7:hover,
  .board-cell.filled-8:hover {
    opacity: 0.7;
    cursor: pointer;
  }

  .board-cell.inactive {
    background: #d1d5db !important;
    opacity: 0.5;
  }

  .board-cell.preview {
    background: #93c5fd;
    opacity: 0.6;
  }

  .board-cell.preview-invalid {
    background: #fca5a5;
    opacity: 0.6;
  }

  #status {
    margin-top: 20px;
    font-size: 1.2rem;
    font-weight: bold;
    color: #333;
  }

  #status.win {
    color: #16a34a;
    font-size: 1.5rem;
    animation: celebrate 0.6s ease-in-out infinite alternate;
  }

  @keyframes celebrate {
    0% {
      transform: scale(1);
    }
    100% {
      transform: scale(1.1);
    }
  }

  .confetti {
    position: fixed;
    width: 10px;
    height: 10px;
    background: #ff6b6b;
    pointer-events: none;
    z-index: 1000;
    animation: confetti-fall linear forwards;
  }

  @keyframes confetti-fall {
    0% {
      transform: translateY(-100vh) rotate(0deg);
      opacity: 1;
    }
    100% {
      transform: translateY(100vh) rotate(720deg);
      opacity: 0;
    }
  }

  .cell-size-3 { width: 60px; height: 60px; }
  .cell-size-4 { width: 50px; height: 50px; }
  .cell-size-5 { width: 45px; height: 45px; }
  .cell-size-6 { width: 40px; height: 40px; }
  .cell-size-7 { width: 35px; height: 35px; }
  .cell-size-8 { width: 32px; height: 32px; }
</style>
</head>
<body>

<div style="position: absolute; top: 20px; left: 20px; z-index: 10;">
  <a href="index.html" style="display: inline-block; padding: 8px 16px; background: #2563eb; color: white; text-decoration: none; border-radius: 4px; font-size: 0.95rem; font-weight: bold; transition: background 0.2s, transform 0.2s; box-shadow: 0 2px 4px rgba(0,0,0,0.1);" onmouseover="this.style.background='#1d4ed8'; this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 8px rgba(0,0,0,0.2)'" onmouseout="this.style.background='#2563eb'; this.style.transform=''; this.style.boxShadow='0 2px 4px rgba(0,0,0,0.1)'">‚Üê Back to Home</a>
</div>

<h1>Tiling Puzzle</h1>

<div id="controls">
  <div style="display: flex; align-items: center; gap: 10px;">
    <label>Shapes:</label>
    <div style="display: flex; gap: 15px;">
      <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
        <input type="checkbox" id="shapeL" value="L" checked>
        <span>L-Shape</span>
      </label>
      <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
        <input type="checkbox" id="shapeS" value="S">
        <span>S-Shape</span>
      </label>
      <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
        <input type="checkbox" id="shapeT" value="T">
        <span>T-Shape</span>
      </label>
    </div>
  </div>
  <label for="gridSizeSelect">Grid Size:</label>
  <select id="gridSizeSelect">
    <option value="4">4x4</option>
    <option value="5">5x5</option>
    <option value="6">6x6</option>
    <option value="7">7x7</option>
    <option value="8">8x8</option>
  </select>
  <div id="rotationControls">
    <button id="rotateLeftBtn">‚Ü∫ Rotate Left</button>
    <button id="rotateRightBtn">‚Üª Rotate Right</button>
    <button id="flipVerticalBtn">‚Üï Flip Vertical</button>
    <button id="flipHorizontalBtn">‚Üî Flip Horizontal</button>
  </div>
  <button id="resetBtn">Reset</button>
</div>

<div id="gameContainer">
  <div id="shapePreview">
    <h3>Current Shape</h3>
    <div id="shapePreviewGrid"></div>
  </div>
  <div id="board"></div>
</div>

<div id="status">Select shapes to use, then click and drag or click a cell to place the active shape (click filled cells to remove)</div>

<script>
  const board = document.getElementById("board");
  const statusText = document.getElementById("status");
  const resetBtn = document.getElementById("resetBtn");
  const shapeLCheckbox = document.getElementById("shapeL");
  const shapeSCheckbox = document.getElementById("shapeS");
  const shapeTCheckbox = document.getElementById("shapeT");
  const gridSizeSelect = document.getElementById("gridSizeSelect");
  const rotateLeftBtn = document.getElementById("rotateLeftBtn");
  const rotateRightBtn = document.getElementById("rotateRightBtn");
  const flipVerticalBtn = document.getElementById("flipVerticalBtn");
  const flipHorizontalBtn = document.getElementById("flipHorizontalBtn");
  const shapePreviewGrid = document.getElementById("shapePreviewGrid");

  let gridSize = 4;
  let boardState = [];
  let currentRotation = 0;
  let currentFlipVertical = false;
  let currentFlipHorizontal = false;
  let shapeIdCounter = 1;
  let previewRow = null;
  let previewCol = null;
  let hasWon = false;
  let selectedShapes = new Set(['L']); // Track which shapes are selected
  let activeShapeType = 'L'; // Currently active shape for placement

  // Shape definitions
  const shapeDefinitions = {
    L: [[0,0], [1,0], [2,0], [2,1]],  // L-Shape
    S: [[0,1], [0,2], [1,0], [1,1]],  // S-Shape (like tetris S)
    T: [[0,1], [1,0], [1,1], [1,2]]   // T-Shape (like tetris T)
  };
  
  const defaultLShape = shapeDefinitions.L;
  let lShape = defaultLShape;
  let customShapes = [];
  let customGridState = null; // null = all cells active, array = custom grid
  let isCustomProblem = false;

  function normalizeShape(cells) {
    // Normalize shape to start at [0,0]
    const minRow = Math.min(...cells.map(c => c[0]));
    const minCol = Math.min(...cells.map(c => c[1]));
    return cells.map(([r, c]) => [r - minRow, c - minCol]);
  }

  function rotateShape(cells, rotations) {
    let rotated = cells.map(([r, c]) => [r, c]);
    for (let i = 0; i < rotations; i++) {
      rotated = rotated.map(([r, c]) => [-c, r]);
    }
    return normalizeShape(rotated);
  }

  function flipShape(cells, horizontal) {
    let flipped = cells.map(([r, c]) => [r, c]);
    if (horizontal) {
      const maxCol = Math.max(...flipped.map(c => c[1]));
      flipped = flipped.map(([r, c]) => [r, maxCol - c]);
    } else {
      const maxRow = Math.max(...flipped.map(c => c[0]));
      flipped = flipped.map(([r, c]) => [maxRow - r, c]);
    }
    return normalizeShape(flipped);
  }

  function getCurrentShape(shapeType = null) {
    // Get the base shape based on current selection
    let baseShape;
    const typeToUse = shapeType || activeShapeType;
    
    if (isCustomProblem && customShapes.length > 0) {
      baseShape = customShapes[0];
    } else {
      baseShape = shapeDefinitions[typeToUse] || shapeDefinitions.L;
    }
    
    let shape = normalizeShape(baseShape);
    shape = rotateShape(shape, currentRotation);
    if (currentFlipVertical) {
      shape = flipShape(shape, false);
    }
    if (currentFlipHorizontal) {
      shape = flipShape(shape, true);
    }
    return shape;
  }
  
  function getSelectedShapes() {
    const selected = [];
    if (shapeLCheckbox.checked) selected.push('L');
    if (shapeSCheckbox.checked) selected.push('S');
    if (shapeTCheckbox.checked) selected.push('T');
    return selected;
  }

  function renderShapePreview() {
    const selected = getSelectedShapes();
    
    if (selected.length === 0) {
      shapePreviewGrid.innerHTML = '<p style="color: #999; text-align: center; padding: 20px;">Select at least one shape</p>';
      return;
    }
    
    // If active shape is not selected, switch to first selected
    if (!selected.includes(activeShapeType)) {
      activeShapeType = selected[0];
    }
    
    shapePreviewGrid.innerHTML = "";
    shapePreviewGrid.style.display = "flex";
    shapePreviewGrid.style.flexWrap = "wrap";
    shapePreviewGrid.style.gap = "15px";
    shapePreviewGrid.style.justifyContent = "center";
    
    selected.forEach(shapeType => {
      const shapeOption = document.createElement("div");
      shapeOption.className = `shape-option ${shapeType === activeShapeType ? 'active' : ''}`;
      shapeOption.dataset.shapeType = shapeType;
      
      const title = document.createElement("h4");
      title.textContent = `${shapeType}-Shape`;
      shapeOption.appendChild(title);
      
      const shapeGrid = document.createElement("div");
      const baseShape = shapeDefinitions[shapeType];
      const shape = shapeType === activeShapeType ? getCurrentShape(shapeType) : normalizeShape(baseShape);
      
      const maxRow = Math.max(...shape.map(c => c[0]));
      const maxCol = Math.max(...shape.map(c => c[1]));
      
      shapeGrid.style.display = "grid";
      shapeGrid.style.gridTemplateColumns = `repeat(${maxCol + 1}, auto)`;
      shapeGrid.style.gap = "3px";
      shapeGrid.style.padding = "10px";
      shapeGrid.style.background = "#e5e5e5";
      shapeGrid.style.borderRadius = "4px";
      shapeGrid.style.justifyContent = "center";
      
      for (let r = 0; r <= maxRow; r++) {
        for (let c = 0; c <= maxCol; c++) {
          const cell = document.createElement("div");
          cell.className = "preview-shape-cell";
          if (!shape.some(([sr, sc]) => sr === r && sc === c)) {
            cell.classList.add("empty");
          }
          shapeGrid.appendChild(cell);
        }
      }
      
      shapeOption.appendChild(shapeGrid);
      
      // Click to activate this shape
      shapeOption.addEventListener("click", () => {
        if (shapeType === activeShapeType) {
          // If clicking the active shape, use it for placement
          return;
        }
        // Switch active shape
        document.querySelectorAll(".shape-option").forEach(opt => opt.classList.remove("active"));
        shapeOption.classList.add("active");
        activeShapeType = shapeType;
        currentRotation = 0;
        currentFlipVertical = false;
        currentFlipHorizontal = false;
        renderShapePreview();
      });
      
      shapePreviewGrid.appendChild(shapeOption);
    });
    
    // Make preview draggable
    setupDragAndDrop();
  }
  
  function createDragGhost(shape) {
    const ghost = document.createElement("div");
    ghost.className = "drag-ghost";
    const maxRow = Math.max(...shape.map(c => c[0]));
    const maxCol = Math.max(...shape.map(c => c[1]));
    
    ghost.style.display = "grid";
    ghost.style.gridTemplateColumns = `repeat(${maxCol + 1}, auto)`;
    ghost.style.gap = "3px";
    ghost.style.padding = "10px";
    ghost.style.background = "rgba(37, 99, 235, 0.9)";
    ghost.style.borderRadius = "8px";
    ghost.style.boxShadow = "0 4px 12px rgba(0,0,0,0.3)";
    
    for (let r = 0; r <= maxRow; r++) {
      for (let c = 0; c <= maxCol; c++) {
        const cell = document.createElement("div");
        cell.style.width = "30px";
        cell.style.height = "30px";
        if (shape.some(([sr, sc]) => sr === r && sc === c)) {
          cell.style.background = "#2563eb";
          cell.style.borderRadius = "2px";
        } else {
          cell.style.background = "transparent";
        }
        ghost.appendChild(cell);
      }
    }
    
    return ghost;
  }
  
  let dragGhost = null;
  let isDragging = false;
  let dragMouseMoveHandler = null;
  let dragMouseUpHandler = null;
  
  function setupDragAndDrop() {
    const shapePreview = document.getElementById("shapePreview");
    if (!shapePreview) return;
    
    // Remove existing listeners if any
    if (dragMouseMoveHandler) {
      document.removeEventListener("mousemove", dragMouseMoveHandler);
    }
    if (dragMouseUpHandler) {
      document.removeEventListener("mouseup", dragMouseUpHandler);
    }
    
    // Use event delegation on the preview grid
    shapePreviewGrid.onmousedown = (e) => {
      // Don't start drag if clicking on buttons or controls
      if (e.target.tagName === 'BUTTON' || e.target.closest('#rotationControls')) {
        return;
      }
      
      // Find which shape was clicked
      const clickedShapeOption = e.target.closest(".shape-option");
      if (!clickedShapeOption) return;
      
      const shapeType = clickedShapeOption.dataset.shapeType;
      if (!shapeType || !getSelectedShapes().includes(shapeType)) return;
      
      // Activate this shape if not already active
      if (shapeType !== activeShapeType) {
        activeShapeType = shapeType;
        currentRotation = 0;
        currentFlipVertical = false;
        currentFlipHorizontal = false;
        renderShapePreview();
        return; // Re-render and let user click again
      }
      
      e.preventDefault();
      isDragging = true;
      const shape = getCurrentShape(shapeType);
      dragGhost = createDragGhost(shape);
      document.body.appendChild(dragGhost);
      clickedShapeOption.classList.add("dragging");
      
      const updateGhost = (e) => {
        if (dragGhost) {
          dragGhost.style.left = e.clientX + "px";
          dragGhost.style.top = e.clientY + "px";
        }
      };
      
      dragMouseMoveHandler = (e) => {
        if (isDragging && dragGhost) {
          updateGhost(e);
          // Update preview on board
          const boardRect = board.getBoundingClientRect();
          const x = e.clientX - boardRect.left;
          const y = e.clientY - boardRect.top;
          
          if (x >= 0 && x < boardRect.width && y >= 0 && y < boardRect.height) {
            const cellSize = boardRect.width / gridSize;
            const col = Math.floor(x / cellSize);
            const row = Math.floor(y / cellSize);
            
            if (row >= 0 && row < gridSize && col >= 0 && col < gridSize) {
              showPreview(row, col);
            }
          } else {
            clearPreview();
          }
        }
      };
      
      dragMouseUpHandler = (e) => {
        if (isDragging) {
          isDragging = false;
          document.querySelectorAll(".shape-option").forEach(opt => opt.classList.remove("dragging"));
          
          if (dragGhost) {
            dragGhost.remove();
            dragGhost = null;
          }
          
          // Check if dropped on board
          const boardRect = board.getBoundingClientRect();
          const x = e.clientX - boardRect.left;
          const y = e.clientY - boardRect.top;
          
          if (x >= 0 && x < boardRect.width && y >= 0 && y < boardRect.height) {
            const cellSize = boardRect.width / gridSize;
            const col = Math.floor(x / cellSize);
            const row = Math.floor(y / cellSize);
            
            if (row >= 0 && row < gridSize && col >= 0 && col < gridSize) {
              handleCellClick(row, col);
            }
          }
          
          clearPreview();
          document.removeEventListener("mousemove", dragMouseMoveHandler);
          document.removeEventListener("mouseup", dragMouseUpHandler);
          dragMouseMoveHandler = null;
          dragMouseUpHandler = null;
        }
      };
      
      updateGhost(e);
      document.addEventListener("mousemove", dragMouseMoveHandler);
      document.addEventListener("mouseup", dragMouseUpHandler);
    };
  }

  function canPlaceShape(row, col, shape) {
    for (const [dr, dc] of shape) {
      const r = row + dr;
      const c = col + dc;
      if (r < 0 || r >= gridSize || c < 0 || c >= gridSize) {
        return false;
      }
      const index = r * gridSize + c;
      // Check if cell is in active grid area (for custom problems)
      if (customGridState && customGridState[index] === 0) {
        return false;
      }
      if (boardState[index] !== 0) {
        return false;
      }
    }
    return true;
  }

  function placeShape(row, col, shape, shapeId) {
    for (const [dr, dc] of shape) {
      const r = row + dr;
      const c = col + dc;
      boardState[r * gridSize + c] = shapeId;
    }
    renderBoard();
    // checkWin() is called by the caller to handle status messages properly
  }

  function removeShape(shapeId) {
    for (let i = 0; i < boardState.length; i++) {
      if (boardState[i] === shapeId) {
        boardState[i] = 0;
      }
    }
    renderBoard();
    // Only set status if player didn't win (unlikely after removing, but check anyway)
    if (!checkWin()) {
      statusText.textContent = "Shape removed. Click a cell to place a new shape.";
    }
  }

  function clearPreview() {
    if (previewRow !== null && previewCol !== null) {
      const shape = getCurrentShape();
      const cells = document.querySelectorAll(".board-cell");
      
      for (const [dr, dc] of shape) {
        const r = previewRow + dr;
        const c = previewCol + dc;
        if (r >= 0 && r < gridSize && c >= 0 && c < gridSize) {
          const index = r * gridSize + c;
          const cell = cells[index];
          cell.classList.remove("preview", "preview-invalid");
        }
      }
    }
    previewRow = null;
    previewCol = null;
  }

  function showPreview(row, col) {
    clearPreview();
    
    const shape = getCurrentShape();
    const cells = document.querySelectorAll(".board-cell");
    
    // Try to find a valid anchor point where the shape can be placed with the clicked cell as part of it
    let bestAnchorRow = null;
    let bestAnchorCol = null;
    let canPlace = false;
    
    // Try placing with clicked cell at each position in the shape
    for (const [dr, dc] of shape) {
      const anchorRow = row - dr;
      const anchorCol = col - dc;
      
      // Check if clicked cell would be part of this placement and is empty
      let clickedCellInPlacement = false;
      let clickedCellEmpty = true;
      for (const [sr, sc] of shape) {
        if (anchorRow + sr === row && anchorCol + sc === col) {
          clickedCellInPlacement = true;
          if (boardState[row * gridSize + col] !== 0) {
            clickedCellEmpty = false;
          }
          break;
        }
      }
      
      // Only try this anchor if clicked cell is either not in the placement, or is empty
      if ((!clickedCellInPlacement || clickedCellEmpty) && canPlaceShape(anchorRow, anchorCol, shape)) {
        bestAnchorRow = anchorRow;
        bestAnchorCol = anchorCol;
        canPlace = true;
        break;
      }
    }
    
    if (bestAnchorRow !== null && bestAnchorCol !== null) {
      // Show preview at the best anchor point
      for (const [dr, dc] of shape) {
        const r = bestAnchorRow + dr;
        const c = bestAnchorCol + dc;
        if (r >= 0 && r < gridSize && c >= 0 && c < gridSize) {
          const index = r * gridSize + c;
          const cell = cells[index];
          if (boardState[index] === 0) {
            cell.classList.add(canPlace ? "preview" : "preview-invalid");
          }
        }
      }
      
      previewRow = bestAnchorRow;
      previewCol = bestAnchorCol;
    }
  }

  function handleCellClick(row, col) {
    // If cell is filled, remove the shape
    const shapeId = boardState[row * gridSize + col];
    if (shapeId !== 0) {
      removeShape(shapeId);
      return;
    }

    const shape = getCurrentShape();
    
    // If there's an active preview and the clicked cell is part of it, use the preview's anchor
    if (previewRow !== null && previewCol !== null) {
      const previewShape = getCurrentShape();
      // Check if clicked cell is part of the preview
      for (const [dr, dc] of previewShape) {
        const r = previewRow + dr;
        const c = previewCol + dc;
        if (r === row && c === col) {
          // Clicked cell is part of preview, use preview's anchor
          if (canPlaceShape(previewRow, previewCol, shape)) {
            placeShape(previewRow, previewCol, shape, shapeIdCounter++);
            clearPreview();
            // Only set status if player didn't win
            if (!checkWin()) {
              statusText.textContent = "Shape placed! Select another cell to place the shape.";
            }
            return;
          }
        }
      }
    }
    
    // Try placing with clicked cell at each position in the shape
    for (const [dr, dc] of shape) {
      const anchorRow = row - dr;
      const anchorCol = col - dc;
      
      if (canPlaceShape(anchorRow, anchorCol, shape)) {
        placeShape(anchorRow, anchorCol, shape, shapeIdCounter++);
        clearPreview();
        // Only set status if player didn't win
        if (!checkWin()) {
          statusText.textContent = "Shape placed! Select another cell to place the shape.";
        }
        return;
      }
    }
    
    // If we get here, couldn't place the shape
    statusText.textContent = "Cannot place shape here. Try another position.";
    statusText.style.color = "#dc2626";
    setTimeout(() => {
      statusText.style.color = "#333";
    }, 2000);
  }

  function renderBoard() {
    // Reset preview tracking
    previewRow = null;
    previewCol = null;
    
    board.innerHTML = "";
    board.style.gridTemplateColumns = `repeat(${gridSize}, auto)`;
    
    for (let r = 0; r < gridSize; r++) {
      for (let c = 0; c < gridSize; c++) {
        const cell = document.createElement("div");
        const index = r * gridSize + c;
        const filledId = boardState[index];
        const isActive = !customGridState || customGridState[index] === 1;
        
        cell.className = `board-cell cell-size-${gridSize}`;
        if (!isActive) {
          cell.classList.add("inactive");
          cell.style.cursor = "not-allowed";
        }
        if (filledId !== 0) {
          cell.classList.add(`filled-${(filledId - 1) % 8 + 1}`);
        }
        
        if (isActive) {
          cell.addEventListener("click", () => handleCellClick(r, c));
          cell.addEventListener("mouseenter", () => showPreview(r, c));
          cell.addEventListener("mouseleave", () => clearPreview());
        }
        board.appendChild(cell);
      }
    }
  }

  function createConfetti() {
    const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#f0932b', '#eb4d4b', '#6c5ce7', '#a29bfe', '#00b894', '#00cec9'];
    const confettiCount = 100;
    
    for (let i = 0; i < confettiCount; i++) {
      setTimeout(() => {
        const confetti = document.createElement('div');
        confetti.className = 'confetti';
        confetti.style.left = Math.random() * 100 + '%';
        confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
        confetti.style.animationDuration = (Math.random() * 3 + 2) + 's';
        confetti.style.animationDelay = Math.random() * 0.5 + 's';
        confetti.style.width = (Math.random() * 10 + 8) + 'px';
        confetti.style.height = (Math.random() * 10 + 8) + 'px';
        confetti.style.borderRadius = Math.random() > 0.5 ? '50%' : '0%';
        
        document.body.appendChild(confetti);
        
        // Remove confetti after animation
        setTimeout(() => {
          confetti.remove();
        }, 5000);
      }, i * 10);
    }
  }

  function getRandomWinMessage() {
    const messages = [
      "üéâ Poop on your butt! You won!",
      "üéâ Awesome sauce! You did it!",
      "üéâ Holy guacamole! You're a winner!",
      "üéâ That's bananas! You won!",
      "üéâ You're the bee's knees! You won!",
      "üéâ That's totally tubular! You won!",
      "üéâ You're a rock star! You won!",
      "üéâ Cowabunga! You won!",
      "üéâ You're the cat's pajamas! You won!",
      "üéâ That's the bomb dot com! You won!",
      "üéâ You're cooler than a penguin! You won!",
      "üéâ That's rad! You won!",
      "üéâ You're the GOAT! You won!",
      "üéâ That's sick! You won!",
      "üéâ You're a legend! You won!",
      "üéâ No way! You actually did it!",
      "üéâ Mind blown! You won!",
      "üéâ You're a puzzle master! You won!",
      "üéâ That's epic! You won!",
      "üéâ You're unstoppable! You won!"
    ];
    return messages[Math.floor(Math.random() * messages.length)];
  }

  function checkWin() {
    let emptyActiveCells = 0;
    for (let i = 0; i < boardState.length; i++) {
      const isActive = !customGridState || customGridState[i] === 1;
      if (isActive && boardState[i] === 0) {
        emptyActiveCells++;
      }
    }
    
    if (emptyActiveCells === 0) {
      if (!hasWon) {
        hasWon = true;
        statusText.textContent = getRandomWinMessage();
        statusText.className = "win";
        createConfetti();
        return true; // Return true if player won
      }
      return true;
    } else {
      hasWon = false;
      statusText.textContent = `${emptyActiveCells} cell(s) remaining. Keep going!`;
      statusText.className = "";
      return false; // Return false if not won
    }
  }

  function loadCustomProblem() {
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get("custom") === "true") {
      const problemData = localStorage.getItem("customTilingProblem");
      if (problemData) {
        try {
          const problem = JSON.parse(problemData);
          isCustomProblem = true;
          gridSize = problem.gridSize;
          customGridState = problem.gridState;
          customShapes = problem.shapes;
          
          if (customShapes.length > 0) {
            lShape = customShapes[0]; // Use first shape as default
          }
          
          gridSizeSelect.value = gridSize;
          localStorage.removeItem("customTilingProblem"); // Clear after loading
          return true;
        } catch (e) {
          console.error("Error loading custom problem:", e);
        }
      }
    }
    return false;
  }

  function resetGame() {
    if (!isCustomProblem) {
      gridSize = parseInt(gridSizeSelect.value);
    }
    boardState = Array(gridSize * gridSize).fill(0);
    currentRotation = 0;
    currentFlipVertical = false;
    currentFlipHorizontal = false;
    shapeIdCounter = 1;
    hasWon = false;
    statusText.textContent = "Click a cell to place the shape (click filled cells to remove)";
    statusText.className = "";
    renderBoard();
    renderShapePreview();
  }

  function rotateLeft() {
    currentRotation = (currentRotation + 1) % 4;
    renderShapePreview();
    if (previewRow !== null && previewCol !== null) {
      showPreview(previewRow, previewCol);
    }
  }

  function rotateRight() {
    currentRotation = (currentRotation + 3) % 4;
    renderShapePreview();
    if (previewRow !== null && previewCol !== null) {
      showPreview(previewRow, previewCol);
    }
  }

  function flipVertical() {
    currentFlipVertical = !currentFlipVertical;
    renderShapePreview();
    if (previewRow !== null && previewCol !== null) {
      showPreview(previewRow, previewCol);
    }
  }

  function flipHorizontal() {
    currentFlipHorizontal = !currentFlipHorizontal;
    renderShapePreview();
    if (previewRow !== null && previewCol !== null) {
      showPreview(previewRow, previewCol);
    }
  }

  resetBtn.addEventListener("click", resetGame);
  
  // Handle shape checkbox changes
  [shapeLCheckbox, shapeSCheckbox, shapeTCheckbox].forEach(checkbox => {
    checkbox.addEventListener("change", () => {
      const selected = getSelectedShapes();
      if (selected.length === 0) {
        // At least one shape must be selected
        checkbox.checked = true;
        return;
      }
      selectedShapes = new Set(selected);
      if (!selected.includes(activeShapeType)) {
        activeShapeType = selected[0];
      }
      renderShapePreview();
    });
  });
  
  gridSizeSelect.addEventListener("change", resetGame);
  rotateLeftBtn.addEventListener("click", rotateLeft);
  rotateRightBtn.addEventListener("click", rotateRight);
  flipVerticalBtn.addEventListener("click", flipVertical);
  flipHorizontalBtn.addEventListener("click", flipHorizontal);

  // Keyboard controls
  document.addEventListener("keydown", (e) => {
    // Only handle if not typing in an input/select
    if (e.target.tagName === "INPUT" || e.target.tagName === "SELECT" || e.target.tagName === "TEXTAREA") {
      return;
    }

    switch(e.key) {
      case "ArrowLeft":
        e.preventDefault();
        rotateLeft();
        break;
      case "ArrowRight":
        e.preventDefault();
        rotateRight();
        break;
      case "ArrowUp":
        e.preventDefault();
        flipVertical();
        break;
      case "ArrowDown":
        e.preventDefault();
        flipVertical();
        break;
    }
  });

  // Initialize
  if (loadCustomProblem()) {
    gridSizeSelect.disabled = true;
    gridSizeSelect.style.opacity = "0.5";
    statusText.textContent = "Custom problem loaded! Click a cell to place shapes.";
  }
  resetGame();
</script>
</body>
</html>
