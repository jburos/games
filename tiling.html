<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Tiling Puzzle</title>
<style>
  body {
    font-family: Arial, sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    margin-top: 20px;
    background: #f5f5f5;
  }

  h1 {
    margin-bottom: 20px;
    color: #333;
  }

  #controls {
    margin-bottom: 20px;
    display: flex;
    gap: 15px;
    align-items: center;
    flex-wrap: wrap;
    justify-content: center;
  }

  #rotationControls {
    display: flex;
    gap: 10px;
  }

  #rotationControls button {
    padding: 6px 12px;
    font-size: 0.9rem;
    background: #6b7280;
  }

  #rotationControls button:hover {
    background: #4b5563;
  }

  label {
    font-size: 1rem;
  }

  select, button {
    padding: 8px 12px;
    font-size: 1rem;
    border: 1px solid #ccc;
    border-radius: 4px;
    background: white;
    cursor: pointer;
  }

  button {
    background: #2563eb;
    color: white;
    border: none;
    font-weight: bold;
  }

  button:hover {
    background: #1d4ed8;
  }

  button:disabled {
    background: #ccc;
    cursor: not-allowed;
  }

  #gameContainer {
    display: flex;
    gap: 30px;
    justify-content: center;
    align-items: flex-start;
    flex-wrap: wrap;
  }

  #shapePreview {
    padding: 20px;
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    min-width: 150px;
  }

  #shapePreview h3 {
    margin: 0 0 15px 0;
    font-size: 1.1rem;
    color: #333;
    text-align: center;
  }

  #shapePreviewGrid {
    display: grid;
    gap: 3px;
    padding: 15px;
    background: #e5e5e5;
    border-radius: 4px;
    justify-content: center;
  }

  .preview-shape-cell {
    width: 30px;
    height: 30px;
    background: #2563eb;
    border-radius: 2px;
  }

  .preview-shape-cell.empty {
    background: transparent;
  }

  #board {
    display: grid;
    gap: 2px;
    background: #333;
    padding: 2px;
    border-radius: 4px;
  }

  .board-cell {
    background: white;
    border-radius: 2px;
    transition: background 0.2s;
  }

  .board-cell:hover {
    background: #e0e7ff;
  }

  .board-cell.filled {
    background: #2563eb;
  }

  .board-cell.filled-1 { background: #2563eb !important; }
  .board-cell.filled-2 { background: #dc2626 !important; }
  .board-cell.filled-3 { background: #16a34a !important; }
  .board-cell.filled-4 { background: #ca8a04 !important; }
  .board-cell.filled-5 { background: #9333ea !important; }
  .board-cell.filled-6 { background: #ea580c !important; }
  .board-cell.filled-7 { background: #0891b2 !important; }
  .board-cell.filled-8 { background: #be123c !important; }

  .board-cell.preview {
    background: #93c5fd;
    opacity: 0.6;
  }

  .board-cell.preview-invalid {
    background: #fca5a5;
    opacity: 0.6;
  }

  #status {
    margin-top: 20px;
    font-size: 1.2rem;
    font-weight: bold;
    color: #333;
  }

  #status.win {
    color: #16a34a;
    font-size: 1.5rem;
  }

  .cell-size-3 { width: 60px; height: 60px; }
  .cell-size-4 { width: 50px; height: 50px; }
  .cell-size-5 { width: 45px; height: 45px; }
  .cell-size-6 { width: 40px; height: 40px; }
  .cell-size-7 { width: 35px; height: 35px; }
  .cell-size-8 { width: 32px; height: 32px; }
</style>
</head>
<body>

<h1>Tiling Puzzle</h1>

<div id="controls">
  <label for="gridSizeSelect">Grid Size:</label>
  <select id="gridSizeSelect">
    <option value="4">4x4</option>
    <option value="5">5x5</option>
    <option value="6">6x6</option>
    <option value="7">7x7</option>
    <option value="8">8x8</option>
  </select>
  <div id="rotationControls">
    <button id="rotateLeftBtn">â†º Rotate Left</button>
    <button id="rotateRightBtn">â†» Rotate Right</button>
    <button id="flipBtn">â†• Flip</button>
  </div>
  <button id="resetBtn">Reset</button>
</div>

<div id="gameContainer">
  <div id="shapePreview">
    <h3>Current Shape</h3>
    <div id="shapePreviewGrid"></div>
  </div>
  <div id="board"></div>
</div>

<div id="status">Click a cell to place the selected shape</div>

<script>
  const board = document.getElementById("board");
  const statusText = document.getElementById("status");
  const resetBtn = document.getElementById("resetBtn");
  const gridSizeSelect = document.getElementById("gridSizeSelect");
  const rotateLeftBtn = document.getElementById("rotateLeftBtn");
  const rotateRightBtn = document.getElementById("rotateRightBtn");
  const flipBtn = document.getElementById("flipBtn");
  const shapePreviewGrid = document.getElementById("shapePreviewGrid");

  let gridSize = 4;
  let boardState = [];
  let currentRotation = 0;
  let currentFlip = false;
  let shapeIdCounter = 1;
  let previewRow = null;
  let previewCol = null;

  // L-Shape definition
  const lShape = [[0,0], [1,0], [2,0], [2,1]];

  function normalizeShape(cells) {
    // Normalize shape to start at [0,0]
    const minRow = Math.min(...cells.map(c => c[0]));
    const minCol = Math.min(...cells.map(c => c[1]));
    return cells.map(([r, c]) => [r - minRow, c - minCol]);
  }

  function rotateShape(cells, rotations) {
    let rotated = cells.map(([r, c]) => [r, c]);
    for (let i = 0; i < rotations; i++) {
      rotated = rotated.map(([r, c]) => [-c, r]);
    }
    return normalizeShape(rotated);
  }

  function flipShape(cells, horizontal) {
    let flipped = cells.map(([r, c]) => [r, c]);
    if (horizontal) {
      const maxCol = Math.max(...flipped.map(c => c[1]));
      flipped = flipped.map(([r, c]) => [r, maxCol - c]);
    } else {
      const maxRow = Math.max(...flipped.map(c => c[0]));
      flipped = flipped.map(([r, c]) => [maxRow - r, c]);
    }
    return normalizeShape(flipped);
  }

  function getCurrentShape() {
    let shape = normalizeShape(lShape);
    shape = rotateShape(shape, currentRotation);
    if (currentFlip) {
      shape = flipShape(shape, false);
    }
    return shape;
  }

  function renderShapePreview() {
    const shape = getCurrentShape();
    const maxRow = Math.max(...shape.map(c => c[0]));
    const maxCol = Math.max(...shape.map(c => c[1]));
    
    shapePreviewGrid.innerHTML = "";
    shapePreviewGrid.style.gridTemplateColumns = `repeat(${maxCol + 1}, auto)`;
    shapePreviewGrid.style.gridTemplateRows = `repeat(${maxRow + 1}, auto)`;
    
    for (let r = 0; r <= maxRow; r++) {
      for (let c = 0; c <= maxCol; c++) {
        const cell = document.createElement("div");
        cell.className = "preview-shape-cell";
        if (!shape.some(([sr, sc]) => sr === r && sc === c)) {
          cell.classList.add("empty");
        }
        shapePreviewGrid.appendChild(cell);
      }
    }
  }

  function canPlaceShape(row, col, shape) {
    for (const [dr, dc] of shape) {
      const r = row + dr;
      const c = col + dc;
      if (r < 0 || r >= gridSize || c < 0 || c >= gridSize) {
        return false;
      }
      if (boardState[r * gridSize + c] !== 0) {
        return false;
      }
    }
    return true;
  }

  function placeShape(row, col, shape, shapeId) {
    for (const [dr, dc] of shape) {
      const r = row + dr;
      const c = col + dc;
      boardState[r * gridSize + c] = shapeId;
    }
    renderBoard();
    checkWin();
  }

  function clearPreview() {
    if (previewRow !== null && previewCol !== null) {
      const shape = getCurrentShape();
      const cells = document.querySelectorAll(".board-cell");
      
      for (const [dr, dc] of shape) {
        const r = previewRow + dr;
        const c = previewCol + dc;
        if (r >= 0 && r < gridSize && c >= 0 && c < gridSize) {
          const index = r * gridSize + c;
          const cell = cells[index];
          cell.classList.remove("preview", "preview-invalid");
        }
      }
    }
    previewRow = null;
    previewCol = null;
  }

  function showPreview(row, col) {
    clearPreview();
    
    const shape = getCurrentShape();
    const cells = document.querySelectorAll(".board-cell");
    
    // Try to find a valid anchor point where the shape can be placed with the clicked cell as part of it
    let bestAnchorRow = null;
    let bestAnchorCol = null;
    let canPlace = false;
    
    // Try placing with clicked cell at each position in the shape
    for (const [dr, dc] of shape) {
      const anchorRow = row - dr;
      const anchorCol = col - dc;
      
      // Check if clicked cell would be part of this placement and is empty
      let clickedCellInPlacement = false;
      let clickedCellEmpty = true;
      for (const [sr, sc] of shape) {
        if (anchorRow + sr === row && anchorCol + sc === col) {
          clickedCellInPlacement = true;
          if (boardState[row * gridSize + col] !== 0) {
            clickedCellEmpty = false;
          }
          break;
        }
      }
      
      // Only try this anchor if clicked cell is either not in the placement, or is empty
      if ((!clickedCellInPlacement || clickedCellEmpty) && canPlaceShape(anchorRow, anchorCol, shape)) {
        bestAnchorRow = anchorRow;
        bestAnchorCol = anchorCol;
        canPlace = true;
        break;
      }
    }
    
    if (bestAnchorRow !== null && bestAnchorCol !== null) {
      // Show preview at the best anchor point
      for (const [dr, dc] of shape) {
        const r = bestAnchorRow + dr;
        const c = bestAnchorCol + dc;
        if (r >= 0 && r < gridSize && c >= 0 && c < gridSize) {
          const index = r * gridSize + c;
          const cell = cells[index];
          if (boardState[index] === 0) {
            cell.classList.add(canPlace ? "preview" : "preview-invalid");
          }
        }
      }
      
      previewRow = bestAnchorRow;
      previewCol = bestAnchorCol;
    }
  }

  function handleCellClick(row, col) {
    if (boardState[row * gridSize + col] !== 0) {
      return; // Cell already filled
    }

    const shape = getCurrentShape();
    
    // If there's an active preview and the clicked cell is part of it, use the preview's anchor
    if (previewRow !== null && previewCol !== null) {
      const previewShape = getCurrentShape();
      // Check if clicked cell is part of the preview
      for (const [dr, dc] of previewShape) {
        const r = previewRow + dr;
        const c = previewCol + dc;
        if (r === row && c === col) {
          // Clicked cell is part of preview, use preview's anchor
          if (canPlaceShape(previewRow, previewCol, shape)) {
            placeShape(previewRow, previewCol, shape, shapeIdCounter++);
            clearPreview();
            statusText.textContent = "L-shape placed! Select another cell to place the shape.";
            return;
          }
        }
      }
    }
    
    // Try placing with clicked cell at each position in the shape
    for (const [dr, dc] of shape) {
      const anchorRow = row - dr;
      const anchorCol = col - dc;
      
      if (canPlaceShape(anchorRow, anchorCol, shape)) {
        placeShape(anchorRow, anchorCol, shape, shapeIdCounter++);
        clearPreview();
        statusText.textContent = "L-shape placed! Select another cell to place the shape.";
        return;
      }
    }
    
    // If we get here, couldn't place the shape
    statusText.textContent = "Cannot place L-shape here. Try another position.";
    statusText.style.color = "#dc2626";
    setTimeout(() => {
      statusText.style.color = "#333";
    }, 2000);
  }

  function renderBoard() {
    // Reset preview tracking
    previewRow = null;
    previewCol = null;
    
    board.innerHTML = "";
    board.style.gridTemplateColumns = `repeat(${gridSize}, auto)`;
    
    for (let r = 0; r < gridSize; r++) {
      for (let c = 0; c < gridSize; c++) {
        const cell = document.createElement("div");
        const index = r * gridSize + c;
        const filledId = boardState[index];
        
        cell.className = `board-cell cell-size-${gridSize}`;
        if (filledId !== 0) {
          cell.classList.add(`filled-${(filledId - 1) % 8 + 1}`);
        }
        
        cell.addEventListener("click", () => handleCellClick(r, c));
        cell.addEventListener("mouseenter", () => showPreview(r, c));
        cell.addEventListener("mouseleave", () => clearPreview());
        board.appendChild(cell);
      }
    }
  }

  function checkWin() {
    const emptyCells = boardState.filter(cell => cell === 0).length;
    if (emptyCells === 0) {
      statusText.textContent = "ðŸŽ‰ Congratulations! You filled the entire grid!";
      statusText.className = "win";
    } else {
      statusText.textContent = `${emptyCells} cell(s) remaining. Keep going!`;
      statusText.className = "";
    }
  }

  function resetGame() {
    gridSize = parseInt(gridSizeSelect.value);
    boardState = Array(gridSize * gridSize).fill(0);
    currentRotation = 0;
    currentFlip = false;
    shapeIdCounter = 1;
    statusText.textContent = "Click a cell to place the L-shape";
    statusText.className = "";
    renderBoard();
    renderShapePreview();
  }

  function rotateLeft() {
    currentRotation = (currentRotation + 3) % 4;
    renderShapePreview();
    if (previewRow !== null && previewCol !== null) {
      showPreview(previewRow, previewCol);
    }
  }

  function rotateRight() {
    currentRotation = (currentRotation + 1) % 4;
    renderShapePreview();
    if (previewRow !== null && previewCol !== null) {
      showPreview(previewRow, previewCol);
    }
  }

  function flip() {
    currentFlip = !currentFlip;
    renderShapePreview();
    if (previewRow !== null && previewCol !== null) {
      showPreview(previewRow, previewCol);
    }
  }

  resetBtn.addEventListener("click", resetGame);
  gridSizeSelect.addEventListener("change", resetGame);
  rotateLeftBtn.addEventListener("click", rotateLeft);
  rotateRightBtn.addEventListener("click", rotateRight);
  flipBtn.addEventListener("click", flip);

  // Initialize
  resetGame();
</script>
</body>
</html>

